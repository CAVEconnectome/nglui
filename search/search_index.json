{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NGLui","text":"<p>Breaking Changes in 4.0.0</p> <p>NGLui has undergone a major upgrade to version 4.0.0, which breaks many of the old features of version 3.x. In doing so, the API should be easier and more consisstent, with new features by focusing on the modern implementation of Neuroglancer and the bleeding edge Spelunker deployment used in many CAVE projects. See the Changelog for more details.</p> <p>NGLui is a Python library to help interacting with Neuroglancer, a web-based viewer for large-scale 3D data visualization. Neuroglancer is designed to visualize large, 3d datasets, such as those found in connectomics, and <code>nglui</code> is designed to make it easier to generate and parse Neuroglancer states. It is particularly useful in the context of the CAVE analysis ecosystem, which provides tools for analyzing, proofreading and visualizing lage-scale connectomics data.</p>"},{"location":"#installation","title":"Installation","text":"<p>To get the most out of NGLui (interacting with source info, uploading skeletons, and more), we suggest installing the full version of NGLui, which includes the <code>cloud-volume</code> dependency:</p> <pre><code>pip install nglui[full]\n</code></pre> <p>You can also install a more minimal version of NGLui without the cloud-volume dependency:</p> <pre><code>pip install nglui\n</code></pre> <p>However, note that cloud-volume is required for some features such as uploading skeletons and getting information about sources during state generation.</p>"},{"location":"#quick-usage","title":"Quick Usage","text":""},{"location":"#building-a-neuroglancer-state-directly","title":"Building a Neuroglancer state directly","text":"<p>Here, let's use the Hemibrain dataset information to build a Neuroglancer state.</p> <pre><code>from nglui import statebuilder\n\nviewer_state = (\n    statebuilder.ViewerState(dimensions=[8,8,8])\n    .add_image_layer(\n        source='precomputed://gs://neuroglancer-janelia-flyem-hemibrain/emdata/clahe_yz/jpeg',\n        name='emdata'\n    )\n    .add_segmentation_layer(\n        source='precomputed://gs://neuroglancer-janelia-flyem-hemibrain/v1.2/segmentation',\n        name='seg',\n        segments=[5813034571],\n    )\n    .add_annotation_layer(\n        source='precomputed://gs://neuroglancer-janelia-flyem-hemibrain/v1.2/synapses',\n        linked_segmentation={'pre_synaptic_cell': 'seg'},\n        filter_by_segmentation=True,\n        color='tomato',\n    )\n)\nviewer_state.to_link(target_url='https://hemibrain-dot-neuroglancer-demo.appspot.com')\n</code></pre> <p>This will return the link: Neuroglancer link.</p>"},{"location":"#building-a-state-from-cave-data","title":"Building a state from CAVE data","text":"<p>Note</p> <p>Using CAVEclient with the MICrONs dataset is required for the following examples. See the MICrONs documentation for how to set up the CAVEclient and access the dataset.</p> <p>Here's a quick example of how to use NGLui to generate a simple Neuroglancer state from the Microns cortical dataset.</p> <pre><code>import caveclient\nfrom nglui import statebuilder\n\nclient = caveclient.CAVEclient('minnie65_public')\n\n# Get a root id of a specific neuron\nroot_id = client.materialize.query_table(\n    'nucleus_detection_v0',\n    filter_equal_dict={'id': 255258}\n)['pt_root_id']\n\nstatebuilder.helpers.make_neuron_neuroglancer_link(\n    client,\n    root_id,\n    show_inputs=True,\n    show_outputs=True,\n)\n</code></pre> <p>This code will generate this link showing a neuron and its synapses.</p>"},{"location":"#additional-features","title":"Additional features","text":"<p>NGLui also has additional features such as:</p> <ul> <li>Parser: Parse neuroglancer states to extract information about layers and annotations.</li> <li>SegmentProperties: Easily build segment property lists from data to make segmentation views more discoverable.</li> <li>SkeletonManager: Upload skeletons to cloud buckets and push quickly into neuroglancer (requires cloud-volume, see Installation).</li> <li>Shaders: Support for better default shaders for neuroglancer layers.</li> </ul>"},{"location":"#development","title":"Development","text":"<p>If you want to clone the repository and develop on NGLui, note that it uses uv for development and packaging, material for mkdocs for documentation, and pre-commit with ruff for code quality checks. Poe-the-poet is used to simplify repetitive tasks, and you can run <code>poe help</code> to see the available tasks.</p>"},{"location":"#migration-from-older-versions","title":"Migration from older versions","text":"<p>If you are migrating from <code>nglui</code> v3.x to v4.0.0+, you will need to dramatically update your code.</p> <p>First and foremost, <code>nglui</code> now only works with contemporary versions of neuroglancer, not the older Seung-lab version. If you still need to support the older deployment, do not upgrade.</p> <p>Please read the new usage documentation! The main change is that it is now recommended to create states directly where possible, and there are now many more convenience functions. Instead of making a bunch of layer configs, now you make a <code>ViewerState</code> object and directly add layers and their information with functions like <code>add_image_layer</code>, <code>add_segmentation_layer</code>, and <code>add_annotation_layer</code>. Instead of always mapping annotation rules and data separately, you can now directly add annotation data through functions like <code>add_points</code> and then export with functions like <code>to_url</code>. You can still use the old pattern of rendering a state and mapping data with DataMap objects. A new \"pipeline\" pattern makes it more efficient to build complex states in a smaller number of lines of code.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This project attempts to follow Semantic Versioning and uses Keep-a-Changelog formatting. But I make mistakes sometimes.</p>"},{"location":"changelog/#451-2025-08-29","title":"[4.5.1] - 2025-08-29","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>StateBuilder: Added support for passing an x,y,z column names explicitly as a list and improved docstrings around this parameter.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>StateBuilder: Slight improvements to docstrings.</li> </ul>"},{"location":"changelog/#450-2025-08-15","title":"[4.5.0] - 2025-08-15","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>StateBuilder: Added RawLayer class that allows for the inclusion of layer specification directly from an existing neuroglancer state. You can also remap sources along the way using the <code>remap_sources</code> method, for example if you are changing states to a new endpoint. The easiest way to access is via <code>ViewerState.add_raw_layer</code>.</li> <li>StateBuilder: Added <code>ViewerState.add_segment_properties</code> function to add segment properties within a viewer state pipeline.</li> <li>StateBuilder: Annotation-adding functions now support adding arrays as well as dataframe columns. Data can now be None and columns can be specified completely.</li> <li>StateBuilder: Added <code>strip_layers</code> function to remove layers from a viewer dictionary to ease its use as a base state.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>StateBuilder: The properties of a base state are better-preserved.</li> </ul>"},{"location":"changelog/#442-2025-06-12","title":"[4.4.2] - 2025-06-12","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>StateBuilder: Added <code>ViewerState.to_browser</code> method that parallels <code>ViewerState.to_url</code> that opens a URL in the browser (h/t Ben Pedigo)</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>StateBuilder: Fixed a bug where the <code>to_url</code> method did not pass the <code>target_url</code> argument to the link shortener.</li> </ul>"},{"location":"changelog/#441-2025-07-01","title":"[4.4.1] - 2025-07-01","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>StateBuilder: Fixed segment properties to use correct auth formatting.</li> </ul>"},{"location":"changelog/#440-2025-06-30","title":"[4.4.0] - 2025-06-30","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>StateBuilder: Added <code>ViewerState.to_clipboard</code> method that parallels <code>ViewerState.to_url</code> that copies the URL or shortened link to the clipboard (h/t Ben Pedigo)</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>StateBuilder: In certain conditions, empty lists were incorrectly being handled.</li> </ul>"},{"location":"changelog/#431-2025-06-25","title":"[4.3.1] - 2025-06-25","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>StateBuilder: More generous error handling when cloudvolume can't do its job for a given source.</li> </ul>"},{"location":"changelog/#430-2025-06-25","title":"[4.3.0] - 2025-06-25","text":"<ul> <li>StateBuilder: Added <code>ViewerState.add_segments</code> and <code>ViewerState.add_segments_from_data</code> to the viewerstate object. They let you add segments to a segmentation layer without breaking a pipeline. Both pass through to SegmentationLayer functions, and default to the first segmentation layer in the state if no layer name is specified.</li> </ul>"},{"location":"changelog/#420-2025-06-25","title":"[4.2.0] - 2025-06-25","text":"<ul> <li>StateBuilder: Added <code>swap_visible_segments_on_move</code> option to AnnotationLayers.</li> </ul>"},{"location":"changelog/#410-2025-06-24","title":"[4.1.0] - 2025-06-24","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>StateBuilder: Added the <code>pick</code> option to layers that enable you to turn off new ID selection (<code>pick=False</code>).</li> <li>StateBuilder: Added <code>color</code> options to <code>add_points</code>/<code>add_lines</code>/etc methods to set the layer color.</li> <li>StateBuilder: Converted <code>viewer_state.layers</code> to a modified list class with names. Only objects with a <code>.name</code> attribute can be added to the list, and objects can be accessed by either name or index.</li> <li>StateBuilder: Added a <code>client</code> argument to <code>ViewerState</code> that will be used as a default for any viewer_state functions that take a client.</li> </ul>"},{"location":"changelog/#400","title":"[4.0.0]","text":"<p>This is a major breaking release that fully changes the way most of the library works. Code from previous verions will not work without significant changes. Parser and SegmentationProperties work as before, but the StateBuilder and EasyViewer modules have been merged with a different pattern and approach. Only the current main and Spelunker branches of Neuroglancer are supported, and the older Seung-lab branch is no longer supported. The following is a small summary of the changes.</p>"},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>StateBuilder/EasyViewer: Complete rewrite joining StateBuilder and Easyviewer into a single module under the statebuilder namespace. Only supports spelunker.</li> <li>StateBuilder: A new SkeletonManager to upload skeletons for use in Neuroglancer.</li> <li>StateBuilder: Support for building some shaders.</li> <li>StateBuilder: Added inference of properties from source info files$$.</li> <li>StateBuilder: Added DataMaps to several places to allow for more flexible data handling and rendering.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>StateBuilder/EasyViewer: Fully removed support for the Seung-lab branch of Neuroglancer. This is no longer supported and will not be updated.</li> <li>StateBuilder/EasyViewer: Removed both main classes and their functionality. Functionality is now merged into the ViewerState class.</li> </ul>"},{"location":"changelog/#382-2025-03-27","title":"[3.8.2] - 2025-03-27","text":""},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Parser Fix issues with dimensions in the parser.</li> </ul>"},{"location":"changelog/#381-2025-01-30","title":"[3.8.1] - 2025-01-30","text":""},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>StateBuilder SegmentationLayerConfig with a color column will ignore <code>None</code> values for data.</li> </ul>"},{"location":"changelog/#380-2025-01-29","title":"[3.8.0] - 2025-01-29","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>StateBuilder Segmentation layers can be set to be non-interactive by default using the <code>selectable</code> parameter in <code>SegmentationLayerConfig</code>. Only works for <code>spelunker</code> branch.</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>StateBuilder Adjusted sphere radius scaling to be correct.</li> </ul>"},{"location":"changelog/#372-2024-12-18","title":"[3.7.2] - 2024-12-18","text":""},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Parser: Fixed a bug in annotation parsing if some layers have tags and some do not.</li> </ul>"},{"location":"changelog/#371-2024-12-11","title":"[3.7.1] - 2024-12-11","text":""},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>StateBuilder:  Fixed a bug where the use of \"helpers.make_state_url\" (which includes most of the helpers) was not using information about urls to infer target sites.</li> </ul>"},{"location":"changelog/#370-2024-12-10","title":"[3.7.0] - 2024-12-10","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>StateBuilder and SegmentProps: A new parameter for segment properties will create columns with a random number for you in a segment property, useful for sampling large lists of ids in neuroglancer.</li> <li>StateBuilder: Made it so that <code>site_utils</code> configuration can be accessed from <code>statebuilder.site_utils</code> instead of needing a separate import.</li> </ul>"},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>StateBuilder: Updated helpers to be compatible with new site_utils functionality.</li> </ul>"},{"location":"changelog/#362-2024-11-22","title":"[3.6.2] - 2024-11-22","text":""},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>Fixed a bug where default configurations were overriding user configurations for target sites.</li> </ul>"},{"location":"changelog/#361-2024-11-20","title":"[3.6.1] - 2024-11-20","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>StateBuilder: Added default configurations to make it much easier to configure links where you want them to go.</li> </ul>"},{"location":"changelog/#352-2024-11-11","title":"[3.5.2] - 2024-11-11","text":""},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>Fixed behavior of <code>statebuilder.helpers.make_neuron_neuroglancer_link</code> to actually render the state as it used to.</li> </ul>"},{"location":"changelog/#351-2024-11-10","title":"[3.5.1] - 2024-11-10","text":""},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li>Removed inadvertent debug statement in the last release.</li> <li>Fixed a bug in the <code>expand_tags</code> option in the <code>annotation_dataframe</code> function.</li> </ul>"},{"location":"changelog/#350-2024-11-10","title":"[3.5.0] - 2024-11-10","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>StateBuilder: Added tags to Spelunker neuroglancer states! Note that this might not be available in all mainline-style deployments yet.</li> <li>Parser: Added a number of new features to parse classic and Spelunker-style states, including layer and segment information, filtering archived layers, and a new class-level interface to make life easier.</li> </ul>"},{"location":"changelog/#fixed_15","title":"Fixed","text":"<ul> <li>Reformatted use of <code>target_site</code> to be more consistent when using \"spelunker\" as a name.</li> </ul>"},{"location":"changelog/#340-2024-08-26","title":"[3.4.0] - 2024-08-26","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>StateBuilder : Added <code>use_skeleton_source</code> as an optional argument for <code>from_client</code> to use a skeleton service advertised in the info service.</li> <li>SegmentProperties New option <code>prepend_col_name</code> in <code>SegmentProperties.from_dataframe</code> will prepend the column name to the tag values.</li> </ul>"},{"location":"changelog/#337-2024-07-24","title":"[3.3.7] - 2024-07-24","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>StateBuilder New option on <code>StateBuilder.render_as</code>: <code>return_as=\"short\"</code> will upload the state and return a short URL to the state.</li> <li>StateBuilder New helper <code>statebuilder.helpers.segment_property_link</code> will quickly generate a basic link from a segment property.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Default \"spelunker\" neuroglancer deployment was changed.</li> </ul>"},{"location":"changelog/#fixed_16","title":"Fixed","text":"<ul> <li>StateBuilder Fixed a bug when setting the background color in Spelunker sites.</li> <li>StateBuilder Fixed a bug in using segment property maps.</li> </ul>"},{"location":"changelog/#336-2024-07-23","title":"[3.3.6] - 2024-07-23","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>SegmentProperties New method \"label_format_map\" allows you to build arbitrary label formats from dataframe columns using </li> </ul>"},{"location":"changelog/#fixed_17","title":"Fixed","text":"<ul> <li>SegmentProperties Nulls in label columns are ignored as intended.</li> </ul>"},{"location":"changelog/#335-2024-07-19","title":"[3.3.5] - 2024-07-19","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>SegmentProperties The <code>label_col</code> argument in <code>SegmentProperties.from_dataframe</code> can now take a list of column names. Labels are concatenated with a seperator set with <code>label_separator</code> that defaults to an underscore (<code>_</code>).</li> <li>StateBuilder Recent segment property arguments included in the segment property maps for SegmentationLayerConfigs.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>SegmentProperties All property names (the <code>id</code> field) are coerced to strings, as required.</li> </ul>"},{"location":"changelog/#334-2024-07-19","title":"[3.3.4] - 2024-07-19","text":""},{"location":"changelog/#fixed_18","title":"Fixed","text":"<ul> <li>SegmentProperties: Fixed a bug in building tags from dataframes.</li> </ul>"},{"location":"changelog/#333-2024-07-19","title":"[3.3.3] - 2024-07-19","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>SegmentProperties: Tag columns will now automatically disambuguate tags if they are duplicated in different columns of the dataframe. For example, if you had \"my_column\" with value \"type_a\" and \"their_column\" also with value \"type_a\", the tag would become \"my_column:type_a\" and \"their_column:type_a\". This can be turned off by setting the <code>allow_disambiguation</code> argument to False.</li> <li>SegmentProperties: The <code>SegmentProperties.from_dataframe</code> method now has a <code>allow_disambiguation</code> argument to control whether the disambiguation above is performed.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>SegmentProperties: Tag property generation performance for long dataframes is improved.</li> </ul>"},{"location":"changelog/#fixed_19","title":"Fixed","text":"<ul> <li>SegmentProperties: Fixed a bug in handling tag columns with categorical dtype.</li> </ul>"},{"location":"changelog/#332-2024-07-18","title":"[3.3.2] - 2024-07-18","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>StateBuilder: When providing a URL but not a client, you will now get a warning that target-site cannot be inferred.</li> </ul>"},{"location":"changelog/#fixed_20","title":"Fixed","text":"<ul> <li>Small changes to work in python 3.8, because the only issue was type hints.</li> </ul>"},{"location":"changelog/#331-2024-07-12","title":"[3.3.1] - 2024-07-12","text":""},{"location":"changelog/#fixed_21","title":"Fixed","text":"<ul> <li>Removed debug statements left in after testing.</li> </ul>"},{"location":"changelog/#330-2024-07-12","title":"[3.3.0] - 2024-07-12","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li>StateBuilder : Added a <code>skeleton_source</code> and <code>skeleton_shader</code> parameter to SegmentationLayerConfig to put skeleton info into the state.</li> <li>EasyViewer : Added <code>set_skeleton_source</code> and <code>set_skeleton_shader</code> methods to EasyViewer.</li> </ul>"},{"location":"changelog/#fixed_22","title":"Fixed","text":"<ul> <li>SegmentProperties : Better handling of null values (nan, None, and empty strings) in tag columns, all of which are ignored.</li> <li>Various requirements updates that were necessary.</li> </ul>"},{"location":"changelog/#321-2024-07-11","title":"[3.2.1] - 2024-07-11","text":""},{"location":"changelog/#added_16","title":"Added","text":"<ul> <li>SegmentProperties : Added a <code>.to_dataframe()</code> method for segment properties to convert them back to a dataframe.</li> </ul>"},{"location":"changelog/#320-2024-07-10","title":"[3.2.0] - 2024-07-10","text":""},{"location":"changelog/#added_17","title":"Added","text":"<ul> <li>SegmentProperties : A new module has been created to build Segment Properties, which are a method of organizing information about segment IDs in a Neuroglancer segmentation layer. Segment Properties only work with the newer Google/Spelunker branches, and offer a way to add browsable and searchable metadata to segments that can be viewed in the viewer.</li> <li>StateBuilder : Various changes were made to support segment properties from both explicit URLs and from data-driven mapping. See documentation for details.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>StateBuilder : Image layers for spelunker now use native contrast controls.</li> </ul>"},{"location":"changelog/#fixed_23","title":"Fixed","text":"<ul> <li>StateBuilder : Improvements to the use of <code>target_site</code> and <code>url_prefix</code> in general when both creating statebuilder and rendering states. In particular, the values in <code>render_state</code> should now correctly take precendence over the values in <code>StateBuilder</code> when both are set.</li> </ul>"},{"location":"changelog/#310-2024-05-29","title":"[3.1.0] - 2024-05-29","text":""},{"location":"changelog/#added_18","title":"Added","text":"<ul> <li>The Parser function <code>annotation_dataframe</code> now has a parameter <code>expand_tags</code> that will create a boolean column for each tag in each annotation layer indicating if the annotation has that tag or not.</li> </ul>"},{"location":"changelog/#fixed_24","title":"Fixed","text":"<ul> <li>Parser : Fixed bugs in getting bounding box annotations and in getting linked segmentations for Spelunker-style states.</li> </ul>"},{"location":"changelog/#303-2024-4-30","title":"[3.0.3] \u2013 2024-4-30","text":""},{"location":"changelog/#fixed_25","title":"Fixed","text":"<ul> <li>StateBuilder : Fixed a bug preventing tags from being set.</li> </ul>"},{"location":"changelog/#302-2024-1-19","title":"[3.0.2] \u2013 2024-1-19","text":""},{"location":"changelog/#fixed_26","title":"Fixed","text":"<ul> <li>Improve consistency of target_site argument in StateBuilder.</li> </ul>"},{"location":"changelog/#301-2023-12-20","title":"[3.0.1] \u2013 2023-12-20","text":""},{"location":"changelog/#fixed_27","title":"Fixed","text":"<ul> <li>Fixed an unnecessary import that caused an error.</li> <li>Added python package neuroglancer to the requirements so versions with errors or incompatibilities can be avoided.</li> </ul>"},{"location":"changelog/#300-2023-12-20","title":"[3.0.0] \u2013 2023-12-20","text":""},{"location":"changelog/#added_19","title":"Added","text":"<ul> <li>StateBuilder and EasyViewer Substantial refactor, adding basic support for the main Google Neuroglancer branch and the Cave-Explorer/Spelunker deployments coming online with CAVE. Most functionality should be seamless, with the client checking for version. Currently, only the Cave-Explorer and Spelunker deployments are fully supported for this automated version check, as the response depends on a build-specific version.json file. If no automated version is set or one wants to override any settings, the <code>target_site</code> argument can be set to <code>cave-explorer</code> or <code>mainline</code> for the main Google branch or <code>seunglab</code> for the older Seung-lab branch.</li> </ul>"},{"location":"changelog/#2141-2023-05-14","title":"[2.14.1] - 2023-05-14","text":""},{"location":"changelog/#fixed_28","title":"Fixed","text":"<ul> <li>StateBuilder Recast all layer names as strings to avoid issues with numeric.</li> </ul>"},{"location":"changelog/#2140-2023-04-12","title":"[2.14.0] - 2023-04-12","text":""},{"location":"changelog/#fixed_29","title":"Fixed","text":"<ul> <li>StateBuilder Fixed various issues with stacking multiple points into a single row.</li> </ul>"},{"location":"changelog/#2130-2023-02-21","title":"[2.13.0] - 2023-02-21","text":""},{"location":"changelog/#added_20","title":"Added","text":"<ul> <li>StateBuilder Adding a helper function for basic line annotation states</li> <li>StateBuilder Helper functions can take <code>split_position</code> argument.</li> </ul>"},{"location":"changelog/#2121-2023-01-30","title":"[2.12.1] - 2023-01-30","text":""},{"location":"changelog/#fixed_30","title":"Fixed","text":"<ul> <li>StateBuilder Handle None data correctly with mapping sets.</li> </ul>"},{"location":"changelog/#2120-2023-01-30","title":"[2.12.0] - 2023-01-30","text":""},{"location":"changelog/#added_21","title":"Added","text":"<ul> <li>EasyViewer At long last, you can set the background color in <code>set_view_options</code> with the argument <code>background_color</code>. As elsewhere, this uses webcolors to deal with color parsing, so it can take names or rgb or hex.</li> <li>StateBuilder StateBuilder can now set the background color in in <code>view_kws</code> with the key <code>background_color</code>.</li> <li>StateBuilder Mapping sets offer a new and simple iapproach to having multiple dataframes with different mapping rules.</li> <li>StateBuilder Mapping rules can handle dataframes where the point position components are split across different columns, assuming that the suffices are always <code>_x</code>, <code>_y</code>, and <code>_z</code>. Set <code>split_positions=True</code> in the mapping rule to use this.</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>StateBuilder Mapping rules now default to <code>set_position = True</code>.</li> </ul>"},{"location":"changelog/#2100-2022-08-11","title":"[2.10.0] - 2022-08-11","text":""},{"location":"changelog/#added_22","title":"Added","text":"<ul> <li>StateBuilder A number of helper functions to produce common states have been added to statebuilder. You can use the function <code>make_neuron_neuroglancer_link</code> to generate a link with one or more root ids and, optionally, their synapses. Further, you can use the function <code>make_synapse_neuroglancer_link</code> to generate a state from a synapse dataframe.</li> <li>StateBuilder Linked segmentations and annotation groups now support multiple columns. For linked segmentations, this adds multiple root ids per annotation. For groups, each unique combinations of values gets its own group.</li> <li>StateBuilder and EasyViewer Colors for layers or segment ids can now be in RGB tuples with values between 0--1 or CSS3 named colors, not just hex.</li> <li>StateBuilder When using the <code>client=</code> argument, viewer resolution is inferred from the client info and does not need to be passed as an additional argument.</li> </ul>"},{"location":"changelog/#fixed_31","title":"Fixed","text":"<ul> <li>StateBuilder For SegmentationLayerConfigs, adding selection maps via <code>add_selection_map</code> is more robust.</li> </ul>"},{"location":"changelog/#272-2021-06-13","title":"[2.7.2] - 2021-06-13","text":""},{"location":"changelog/#fixed_32","title":"Fixed","text":"<ul> <li>StateBuilder Multipoint now works with <code>set_position</code>.</li> </ul>"},{"location":"changelog/#271-2021-06-13","title":"[2.7.1] - 2021-06-13","text":""},{"location":"changelog/#fixed_33","title":"Fixed","text":"<ul> <li>StateBuilder Multipoint performance has improved.</li> </ul>"},{"location":"changelog/#270-2021-06-13","title":"[2.7.0] - 2021-06-13","text":""},{"location":"changelog/#added_23","title":"Added","text":"<ul> <li>StateBuilder In all Mappers, setting <code>multipoint=True</code> will allow the point columns to contain multiple points per row, with the other columns assigned to all points in the row. Note that for Mappers with multiple point columns (e.g. LineMappers, SphereMappers, and BoundingBoxMappers), the number of values must be the same in both columns.</li> </ul>"},{"location":"changelog/#260-2021-06-11","title":"[2.6.0] - 2021-06-11","text":""},{"location":"changelog/#added_24","title":"Added","text":"<ul> <li>StateBuilder You can now set a timestamp in SegmentationLayerConfig. Either datetime or unix epoch are allowed.</li> </ul>"},{"location":"changelog/#250","title":"[2.5.0]","text":"<ul> <li>StateBuilder You can now set split points using a SplitPointMapper</li> </ul>"},{"location":"changelog/#240-2021-01-22","title":"[2.4.0] - 2021-01-22","text":""},{"location":"changelog/#added_25","title":"Added","text":"<ul> <li>Parser: <code>get_selected_ids</code> does what it says for a layer.</li> </ul>"},{"location":"changelog/#fixed_34","title":"Fixed","text":"<ul> <li>Parser: Getting annotations with tags/descriptions/etc works.</li> <li>StateBuilder: <code>return_as</code> parameter works with ChainedStateBuilder now</li> </ul>"},{"location":"changelog/#231-2021-01-15","title":"[2.3.1] - 2021-01-15","text":""},{"location":"changelog/#fixed_35","title":"Fixed","text":"<ul> <li>Remove pytables from requirements, because the pip install does not work on OS X (at least). If you want to run tests, you will need to install either with <code>pip install tables</code> if you're on a system where that works or <code>conda install pytables</code> otherwise.</li> </ul>"},{"location":"changelog/#230-2021-01-14","title":"[2.3.0] - 2021-01-14","text":""},{"location":"changelog/#added_26","title":"Added","text":"<ul> <li>StateBuilder: At long last, a BoundingBoxMapper</li> <li>StateBuilder: A <code>from_client</code> function to generate simple image &amp; segmentation states from a FrameworkClient instance.</li> <li>StateBuilder: Statebuilder can take a client to configure certain default parameters.</li> <li>StateBuilder: SegmentationLayerConfig explicitly takes some view keyword arguments: <code>alpha_selected</code>, <code>alpha_3d</code>, and <code>alpha_unselected</code>.</li> <li>Parser: New options to get annotation groups and group ids for all annotations.</li> <li>Parser: New function to extract multicut information from a state.</li> </ul>"},{"location":"changelog/#fixed_36","title":"Fixed","text":"<ul> <li>StateBuilder: Fixed a scenario where int64s get altered by a conversion through floats.</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Statebuilder: Behind the scenes refactoring that should not affect use.</li> </ul>"},{"location":"changelog/#221-2020-10-21","title":"[2.2.1] \u2014\u00a02020-10-21","text":""},{"location":"changelog/#fixed_37","title":"Fixed","text":"<ul> <li>StateBuilder: Setting view options for Graphene segmentation layers now works</li> <li>Parser: Now imported as a property of nglui if you import as <code>import nglui</code>.</li> <li>Small bug fixes.</li> </ul>"},{"location":"changelog/#220-2020-09-04","title":"[2.2.0] \u2014 2020-09-04","text":""},{"location":"changelog/#added_27","title":"Added","text":"<ul> <li> <p>Parser submodule <code>nglui.parser</code> for quickly extracting data from neuroglancer states. This should remove some of the boilerplate one writes every time you want to get data out of a state.</p> </li> <li> <p>AnnotationLayerConfig now can take arguments about user interactions such as filtering by segmentation and bracket shortcuts showing segmentations.</p> </li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Default behavior for annotation layers now has filtering by segmentation turned off and bracket shortcuts showing segmentations turned on.</li> </ul>"},{"location":"changelog/#211-2020-08-17","title":"[2.1.1] \u2014 2020-08-17","text":""},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Switched from numpy <code>isnan</code> to pandas <code>isnull</code> in StateBuilder. This allows nullable pandas Int64 dtypes to work as columns</li> </ul>"},{"location":"changelog/#210-2020-07-14","title":"[2.1.0] \u2014 2020-07-14","text":""},{"location":"changelog/#added_28","title":"Added","text":"<ul> <li> <p>Grouped annotations in nglite base and EasyViewer's annotation module. This feature lets you create annotation groups in the Seung-lab branches of Neuroglancer, where multiple annotations are related to one another. It works by passing a list of already-created annotations and getting a new \"CollectionAnnotation\" that groups them together.</p> </li> <li> <p>Grouped annotations in StateBuilder. PointMapper, SphereMapper, and LineMapper objects can take a 'group_column' value. Data in this column is intended to be numeric or NaN, and rows that share the same value are grouped together. At the moment, this feature only works within individual mapper objects.</p> </li> <li> <p>Two options for linked segmentation ids on grouped annotations: <code>gather_linked_segmentations</code> assigns all linked ids of objects within the group to the group annotation itself (True by default). <code>share_linked_segmentations</code> will add all linked objects within the group to all annotations within the group (False by default).</p> </li> <li> <p><code>array_data</code> option on AnnotationLayerConfig for simple cases where you just want to map Nx3 arrays to points, a pair of Nx3 arrays to lines, or an Nx3 + N array to spheres (centers+radii).</p> </li> </ul>"},{"location":"changelog/#fixed_38","title":"Fixed","text":"<ul> <li>Bug in GL Shader that caused StateBuilder to fail when <code>constrast_controls</code> was set to True.</li> </ul>"},{"location":"changelog/#202-2020-06-18","title":"[2.0.2] - 2020-06-18","text":""},{"location":"changelog/#added_29","title":"Added","text":"<ul> <li> <p>Custom GL Shaders (see documentation) for image and segmentation layers can be set in EasyViewer.</p> </li> <li> <p>JSON State Server can be set in EasyViewer.</p> </li> <li> <p>Added <code>contrast_controls</code> argument to <code>statebuilder.ImageLayerConfig</code> to provide brightness/contrast controls to layer through GL Shader.</p> </li> <li> <p>Added <code>state_server</code> argument to <code>statebuilder.StateBuilder</code> to pre-set state server endpoints.</p> </li> </ul>"},{"location":"changelog/#201-2020-04-27","title":"[2.0.1] - 2020-04-27","text":""},{"location":"changelog/#fixed_39","title":"Fixed","text":"<ul> <li>Removed unnecessary parts of the included neuroglancer module (<code>nglite</code>) for cleanliness.</li> </ul>"},{"location":"changelog/#200-2020-04-25","title":"[2.0.0] - 2020-04-25","text":"<p>This update significantly changed the underlying nature and goals of the Neuroglancer Annotation UI project.</p>"},{"location":"changelog/#added_30","title":"Added","text":"<ul> <li> <p>StateBuilder module for rule-based method of generating Neuroglancer states from Pandas DataFrames.</p> </li> <li> <p>Added various features to make use of specific aspects of the Seung-lab Neuroglancer fork.</p> </li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Removed dependency on neuroglancer python package, which was not designed for the Seung-Lab Neuroglancer fork and had some difficult install requirements for features that were unnecessary for this project demanded.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Dynamic state management via python server.</li> </ul>"},{"location":"reference/helpers/","title":"statebuilder.helpers","text":"<p>Functions:</p> <ul> <li> <code>make_connectivity_state_map</code>             \u2013              <p>Create a Neuroglancer state with input and output synapses.</p> </li> <li> <code>make_line_state</code>             \u2013              <p>Generate a state builder that puts line segments from two columns with a linked segmentaton id</p> </li> <li> <code>make_neuron_neuroglancer_link</code>             \u2013              <p>Create a Neuroglancer state with a neuron and optionally its inputs and outputs.</p> </li> <li> <code>make_point_state</code>             \u2013              <p>Generate a state builder that puts points on a single column with a linked segmentaton id</p> </li> <li> <code>sort_dataframe_by_root_id</code>             \u2013              <p>Sort a dataframe so that rows belonging to the same root id are together, ordered by how many times the root id appears.</p> </li> </ul>"},{"location":"reference/helpers/#src.nglui.statebuilder.helpers.make_connectivity_state_map","title":"<code>make_connectivity_state_map(client, show_inputs=True, show_outputs=True, point_column='ctr_pt_position', input_root_id_col='pre_pt_root_id', output_root_id_col='post_pt_root_id', dataframe_resolution_input=None, dataframe_resolution_output=None, input_layer_name='syns_in', output_layer_name='syns_out', input_layer_color=DEFAULT_POSTSYN_COLOR, output_layer_color=DEFAULT_PRESYN_COLOR, input_shader=True, output_shader=True, selected_alpha=None, alpha_3d=None, mesh_silhouette=None)</code>","text":"<p>Create a Neuroglancer state with input and output synapses.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>CAVEclient</code>)           \u2013            <p>CAVEclient configured for the datastack desired</p> </li> <li> <code>show_inputs</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to show input synapses, by default True</p> </li> <li> <code>show_outputs</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to show output synapses, by default True</p> </li> <li> <code>point_column</code>               (<code>str</code>, default:                   <code>'ctr_pt_position'</code> )           \u2013            <p>Column in the dataframe to use for point positions, by default \"ctr_pt_position\"</p> </li> <li> <code>input_root_id_col</code>               (<code>str</code>, default:                   <code>'pre_pt_root_id'</code> )           \u2013            <p>Column in the dataframe to use for input synapse root ids, by default \"pre_pt_root_id\"</p> </li> <li> <code>output_root_id_col</code>               (<code>str</code>, default:                   <code>'post_pt_root_id'</code> )           \u2013            <p>Column in the dataframe to use for output synapse root ids, by default \"post_pt_root_id\"</p> </li> <li> <code>dataframe_resolution_input</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>Resolution of the input dataframe, by default None</p> </li> <li> <code>dataframe_resolution_output</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>Resolution of the output dataframe, by default None</p> </li> <li> <code>input_layer_name</code>               (<code>str</code>, default:                   <code>'syns_in'</code> )           \u2013            <p>Name of the input layer, by default \"syns_in\"</p> </li> <li> <code>output_layer_name</code>               (<code>str</code>, default:                   <code>'syns_out'</code> )           \u2013            <p>Name of the output layer, by default \"syns_out\"</p> </li> <li> <code>input_layer_color</code>               (<code>Union[tuple, str]</code>, default:                   <code>DEFAULT_POSTSYN_COLOR</code> )           \u2013            <p>Color of the input layer, by default \"turquoise\"</p> </li> <li> <code>output_layer_color</code>               (<code>Union[tuple, str]</code>, default:                   <code>DEFAULT_PRESYN_COLOR</code> )           \u2013            <p>Color of the output layer, by default \"tomato\"</p> </li> <li> <code>input_shader</code>               (<code>Optional[Union[bool, str]]</code>, default:                   <code>True</code> )           \u2013            <p>Shader to use for input synapses, by default None.</p> </li> <li> <code>output_shader</code>               (<code>Optional[Union[bool, str]]</code>, default:                   <code>True</code> )           \u2013            <p>Shader to use for output synapses, by default None (uses default shader)</p> </li> <li> <code>selected_alpha</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Alpha value for selected segments in the 2d view, by default None (uses default value)</p> </li> <li> <code>alpha_3d</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Alpha value for meshes, by default None (uses default value)</p> </li> <li> <code>mesh_silhouette</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Mesh silhouette value, by default None (uses default value)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ViewerState</code>           \u2013            <p>A Neuroglancer ViewerState with input and output synapses configured.</p> </li> </ul>"},{"location":"reference/helpers/#src.nglui.statebuilder.helpers.make_line_state","title":"<code>make_line_state(client, data=None, point_a_column='pre_pt_position', point_b_column='post_pt_position', segment_column='pt_root_id', description_column=None, tag_column=None, data_resolution=None, tags=None, layer_name='lines', shader=True, selected_alpha=None, alpha_3d=None, mesh_silhouette=None)</code>","text":"<p>Generate a state builder that puts line segments from two columns with a linked segmentaton id</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>CAVEclient</code>)           \u2013            <p>CAVEclient configured for the datastack desired</p> </li> <li> <code>data</code>               (<code>Optional[DataFrame]</code>, default:                   <code>None</code> )           \u2013            <p>Dataframe to use for points, by default None. If None, a simple DataMap will be used with no key. Fill in the resulting state with viewer.map(df).</p> </li> <li> <code>point_a_column</code>               (<code>str</code>, default:                   <code>'pre_pt_position'</code> )           \u2013            <p>Column in the dataframe to use for line start positions, by default \"pre_pt_position\"</p> </li> <li> <code>point_b_column</code>               (<code>str</code>, default:                   <code>'post_pt_position'</code> )           \u2013            <p>Column in the dataframe to use for line end, by default \"post_pt_position\"</p> </li> <li> <code>segment_column</code>               (<code>str</code>, default:                   <code>'pt_root_id'</code> )           \u2013            <p>Column in the dataframe to use for segment ids, by default \"pt_root_id\"</p> </li> <li> <code>description_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Column in the dataframe to use for point descriptions, by default None</p> </li> <li> <code>tag_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Column in the dataframe to use for tags, by default None</p> </li> <li> <code>data_resolution</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>Resolution of the data, by default None</p> </li> <li> <code>tags</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>List of tags to apply to the points, by default None</p> </li> <li> <code>layer_name</code>               (<code>str</code>, default:                   <code>'lines'</code> )           \u2013            <p>Name of the layer to create, by default \"Points\"</p> </li> <li> <code>shader</code>               (<code>Optional[Union[bool, str]]</code>, default:                   <code>True</code> )           \u2013            <p>Shader to use for the points, by default True (uses default shader)</p> </li> <li> <code>selected_alpha</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Alpha value for selected segments in the 2D view, by default None (uses default value)</p> </li> <li> <code>alpha_3d</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Alpha value for meshes, by default None (uses default value)</p> </li> <li> <code>mesh_silhouette</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Mesh silhouette value, by default None (uses default value)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ViewerState</code> (              <code>ViewerState</code> )          \u2013            <p>A viewerstate to make points with linked segmentations</p> </li> </ul>"},{"location":"reference/helpers/#src.nglui.statebuilder.helpers.make_neuron_neuroglancer_link","title":"<code>make_neuron_neuroglancer_link(client, root_ids, return_as='link', shorten='if_long', show_inputs=True, show_outputs=True, point_column='ctr_pt_position', target_url=None, target_site=None, timestamp=None, infer_coordinates=True)</code>","text":"<p>Create a Neuroglancer state with a neuron and optionally its inputs and outputs.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>CAVEclient</code>)           \u2013            <p>CAVEclient configured for the datastack desired</p> </li> <li> <code>root_ids</code>               (<code>Union[int, list[int]]</code>)           \u2013            <p>Root IDs of the neuron to visualize. Can be a single ID or a list of IDs.</p> </li> <li> <code>return_as</code>               (<code>Literal['link', 'dict', 'json', 'url']</code>, default:                   <code>'link'</code> )           \u2013            <p>Format to return the Neuroglancer state, by default \"link\". Options are \"link\", \"dict\", \"json\", or \"url\".</p> </li> <li> <code>shorten</code>               (<code>Literal['never', 'always', 'if_long']</code>, default:                   <code>'if_long'</code> )           \u2013            <p>Whether to shorten the URL if it is long, by default \"if_long\". Options are \"never\", \"always\", or \"if_long\".</p> </li> <li> <code>show_inputs</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to show input synapses, by default True</p> </li> <li> <code>show_outputs</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to show output synapses, by default True</p> </li> <li> <code>point_column</code>               (<code>str</code>, default:                   <code>'ctr_pt_position'</code> )           \u2013            <p>Column in the dataframe to use for point positions, by default \"ctr_pt_position\"</p> </li> <li> <code>target_url</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Target URL to use for the Neuroglancer link, by default None. If None, the default CAVEclient URL will be used.</p> </li> <li> <code>target_site</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Target site to use for the Neuroglancer link, by default None. If None, the default CAVEclient site will be used.</p> </li> <li> <code>timestamp</code>               (<code>Optional[datetime]</code>, default:                   <code>None</code> )           \u2013            <p>Timestamp to use for the query, by default None. If None, the current time will be used.</p> </li> <li> <code>infer_coordinates</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to infer coordinates from the data, by default True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Neuroglancer state in the specified format.</code>           \u2013            </li> </ul>"},{"location":"reference/helpers/#src.nglui.statebuilder.helpers.make_point_state","title":"<code>make_point_state(client, data=None, point_column='pt_position', segment_column='pt_root_id', description_column=None, tag_column=None, data_resolution=None, tags=None, layer_name='Points', shader=True, selected_alpha=None, alpha_3d=None, mesh_silhouette=None)</code>","text":"<p>Generate a state builder that puts points on a single column with a linked segmentaton id</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>CAVEclient</code>)           \u2013            <p>CAVEclient configured for the datastack desired</p> </li> <li> <code>data</code>               (<code>Optional[DataFrame]</code>, default:                   <code>None</code> )           \u2013            <p>Dataframe to use for points, by default None. If None, a simple DataMap will be used with no key. Fill in the resulting state with viewer.map(df).</p> </li> <li> <code>point_column</code>               (<code>str</code>, default:                   <code>'pt_position'</code> )           \u2013            <p>Column in the dataframe to use for point positions, by default \"pt_position\"</p> </li> <li> <code>segment_column</code>               (<code>str</code>, default:                   <code>'pt_root_id'</code> )           \u2013            <p>Column in the dataframe to use for segment ids, by default \"pt_root_id\"</p> </li> <li> <code>description_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Column in the dataframe to use for point descriptions, by default None</p> </li> <li> <code>tag_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Column in the dataframe to use for tags, by default None</p> </li> <li> <code>data_resolution</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>Resolution of the data, by default None</p> </li> <li> <code>tags</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>List of tags to apply to the points, by default None</p> </li> <li> <code>layer_name</code>               (<code>str</code>, default:                   <code>'Points'</code> )           \u2013            <p>Name of the layer to create, by default \"Points\"</p> </li> <li> <code>shader</code>               (<code>Optional[Union[bool, str]]</code>, default:                   <code>True</code> )           \u2013            <p>Shader to use for the points, by default True (uses default shader)</p> </li> <li> <code>selected_alpha</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Alpha value for selected segments in the 2D view, by default None (uses default value)</p> </li> <li> <code>alpha_3d</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Alpha value for meshes, by default None (uses default value)</p> </li> <li> <code>mesh_silhouette</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Mesh silhouette value, by default None (uses default value)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ViewerState</code> (              <code>ViewerState</code> )          \u2013            <p>A viewerstate to make points with linked segmentations</p> </li> </ul>"},{"location":"reference/helpers/#src.nglui.statebuilder.helpers.sort_dataframe_by_root_id","title":"<code>sort_dataframe_by_root_id(df, root_id_column, ascending=False, num_column='n_times', drop=False)</code>","text":"<p>Sort a dataframe so that rows belonging to the same root id are together, ordered by how many times the root id appears.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>dataframe to sort</p> </li> <li> <code>root_id_column</code>               (<code>str</code>)           \u2013            <p>Column name to use for sorting root ids</p> </li> <li> <code>ascending</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to sort ascending (lowest count to highest) or not, by default False</p> </li> <li> <code>num_column</code>               (<code>str</code>, default:                   <code>'n_times'</code> )           \u2013            <p>Temporary column name to use for count information, by default 'n_times'</p> </li> <li> <code>drop</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, drop the additional column when returning.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            </li> </ul>"},{"location":"reference/ngl_annotations/","title":"statebuilder.ngl_annotations","text":"<p>Functions:</p> <ul> <li> <code>make_annotation_properties</code>             \u2013              <p>Take a list of annotations and build up the dictionary needed</p> </li> <li> <code>make_bindings</code>             \u2013              <p>Make a dictinary describing key bindings for tags</p> </li> </ul>"},{"location":"reference/ngl_annotations/#src.nglui.statebuilder.ngl_annotations.make_annotation_properties","title":"<code>make_annotation_properties(annotations, tag_base_number=0)</code>","text":"<p>Take a list of annotations and build up the dictionary needed</p>"},{"location":"reference/ngl_annotations/#src.nglui.statebuilder.ngl_annotations.make_bindings","title":"<code>make_bindings(properties, bindings=None)</code>","text":"<p>Make a dictinary describing key bindings for tags</p>"},{"location":"reference/ngl_components/","title":"statebuilder.ngl_components","text":"<p>Classes:</p> <ul> <li> <code>AnnotationLayer</code>           \u2013            </li> <li> <code>CoordSpace</code>           \u2013            <p>Coordinate space for Neuroglancer.</p> </li> <li> <code>CoordSpaceTransform</code>           \u2013            <p>Coordinate space transform for Neuroglancer.</p> </li> <li> <code>DataMap</code>           \u2013            <p>Class to defer mapping of dataframes to a ViewerState or Layer.</p> </li> <li> <code>ImageLayer</code>           \u2013            <p>Configuration for a Neuroglancer image layer.</p> </li> <li> <code>Layer</code>           \u2013            </li> <li> <code>LayerWithSource</code>           \u2013            </li> <li> <code>RawLayer</code>           \u2013            <p>Configuration for a Neuroglancer raw layer from a data source</p> </li> <li> <code>SegmentationLayer</code>           \u2013            <p>Configuration for a Neuroglancer segmentation layer.</p> </li> <li> <code>Source</code>           \u2013            <p>Configuration for a Neuroglancer data source.</p> </li> <li> <code>UnmappedDataError</code>           \u2013            <p>Exception raised when a layer is not fully mapped to a datamap.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>segments_to_neuroglancer</code>             \u2013              <p>Convert a flat or mixed-visibility segment list to Neuroglancer.</p> </li> <li> <code>source_to_neuroglancer</code>             \u2013              <p>Convert a possibly multi-url source to a Neuroglancer-compatible format.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.AnnotationLayer","title":"<code>AnnotationLayer</code>","text":"<p>               Bases: <code>LayerWithSource</code></p> <p>Methods:</p> <ul> <li> <code>add_annotations</code>             \u2013              <p>Add annotations to the layer.</p> </li> <li> <code>add_boxes</code>             \u2013              <p>Add point annotations to the layer.</p> </li> <li> <code>add_ellipsoids</code>             \u2013              <p>Add point annotations to the layer.</p> </li> <li> <code>add_lines</code>             \u2013              <p>Add point annotations to the layer.</p> </li> <li> <code>add_points</code>             \u2013              <p>Add point annotations to the layer.</p> </li> <li> <code>add_shader</code>             \u2013              <p>Add a shader to the layer.</p> </li> <li> <code>apply_to_neuroglancer</code>             \u2013              <p>Can be a viewer or a viewer.txn()-context state</p> </li> <li> <code>set_linked_segmentation</code>             \u2013              <p>Add a linked segmentation layer to the annotation layer.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.AnnotationLayer.add_annotations","title":"<code>add_annotations(annotations)</code>","text":"<p>Add annotations to the layer.</p> <p>Parameters:</p> <ul> <li> <code>annotations</code>               (<code>list</code>)           \u2013            <p>The annotations to add.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>self</code>           \u2013            <p>The AnnotationLayer object with added annotations.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.AnnotationLayer.add_boxes","title":"<code>add_boxes(data, point_a_column, point_b_column, segment_column=None, description_column=None, tag_column=None, tag_bools=None, data_resolution=None)</code>","text":"<p>Add point annotations to the layer.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>The DataFrame containing the point annotations.</p> </li> <li> <code>point_a_column</code>               (<code>str</code>)           \u2013            <p>The column name for the start point coordinates of the box. Can be a prefix for a split column name with _x, _y, _z as suffixes.</p> </li> <li> <code>point_b_column</code>               (<code>str</code>)           \u2013            <p>The column name for the end point coordinates of the box Can be a prefix for a split column name with _x, _y, _z as suffixes.</p> </li> <li> <code>segment_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the segment IDs. Default is None.</p> </li> <li> <code>description_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the segment descriptions. Default is None.</p> </li> <li> <code>data_resolution</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the data. Default is None.</p> </li> <li> <code>tag_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the tags. Default is None. Row values should be strings. Nones and NAs will be skipped.</p> </li> <li> <code>tag_bools</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>List of column names to treat as a tag, with values being booleans indicating whether the tag is present or not. Default is None.</p> </li> <li> <code>data_resolution</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the data. If None, follows from layer resolution. Default is None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationLayer</code>           \u2013            <p>The SegmentationLayer object with added point annotations.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.AnnotationLayer.add_ellipsoids","title":"<code>add_ellipsoids(data, center_column, radii_column, segment_column=None, description_column=None, tag_column=None, tag_bools=None, data_resolution=None)</code>","text":"<p>Add point annotations to the layer.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>The DataFrame containing the point annotations.</p> </li> <li> <code>center_column</code>               (<code>str</code>)           \u2013            <p>The column name for the center point coordinates. Can be a prefix for a split column name with _x, _y, _z as suffixes.</p> </li> <li> <code>radii_column</code>               (<code>str</code>)           \u2013            <p>The column name for the radius values. Can be a prefix for a split column name with _x, _y, _z as suffixes.</p> </li> <li> <code>segment_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the segment IDs. Default is None.</p> </li> <li> <code>description_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the segment descriptions. Default is None.</p> </li> <li> <code>data_resolution</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the data. Default is None.</p> </li> <li> <code>tag_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the tags. Default is None. Row values should be strings. Nones and NAs will be skipped.</p> </li> <li> <code>tag_bools</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>List of column names to treat as a tag, with values being booleans indicating whether the tag is present or not. Default is None.</p> </li> <li> <code>data_resolution</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the data. If None, follows from layer resolution. Default is None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationLayer</code>           \u2013            <p>The SegmentationLayer object with added point annotations.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.AnnotationLayer.add_lines","title":"<code>add_lines(data, point_a_column, point_b_column, segment_column=None, description_column=None, tag_column=None, tag_bools=None, data_resolution=None)</code>","text":"<p>Add point annotations to the layer.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>The DataFrame containing the point annotations.</p> </li> <li> <code>point_a_column</code>               (<code>str</code>)           \u2013            <p>The column name for the start point coordinates. Can be a prefix for a split column name with _x, _y, _z as suffixes.</p> </li> <li> <code>point_b_column</code>               (<code>str</code>)           \u2013            <p>The column name for the end point coordinates. Can be a prefix for a split column name with _x, _y, _z as suffixes.</p> </li> <li> <code>segment_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the segment IDs. Default is None.</p> </li> <li> <code>description_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the segment descriptions. Default is None.</p> </li> <li> <code>data_resolution</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the data. Default is None.</p> </li> <li> <code>tag_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the tags. Default is None. Row values should be strings. Nones and NAs will be skipped.</p> </li> <li> <code>tag_bools</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>List of column names to treat as a tag, with values being booleans indicating whether the tag is present or not. Default is None.</p> </li> <li> <code>data_resolution</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the data. If None, follows from layer resolution. Default is None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationLayer</code>           \u2013            <p>The SegmentationLayer object with added point annotations.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.AnnotationLayer.add_points","title":"<code>add_points(data, point_column=None, segment_column=None, description_column=None, tag_column=None, tag_bools=None, data_resolution=None)</code>","text":"<p>Add point annotations to the layer.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame or ndarray</code>)           \u2013            <p>The DataFrame containing the point annotations or an Nx3 array. If using an array, there is no way to set segment IDs, descriptions, or tags.</p> </li> <li> <code>point_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the point coordinates. Can be a prefix for a split column name with _x, _y, _z as suffixes.</p> </li> <li> <code>segment_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the segment IDs. Default is None.</p> </li> <li> <code>description_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the segment descriptions. Default is None.</p> </li> <li> <code>tag_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for segment descripion. Default is None.</p> </li> <li> <code>tag_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the tags. Default is None. Row values should be strings. Nones and NAs will be skipped.</p> </li> <li> <code>tag_bools</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>List of column names to treat as a tag, with values being booleans indicating whether the tag is present or not. Default is None.</p> </li> <li> <code>data_resolution</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the data. If None, follows from layer resolution. Default is None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationLayer</code>           \u2013            <p>The SegmentationLayer object with added point annotations.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.AnnotationLayer.add_shader","title":"<code>add_shader(shader)</code>","text":"<p>Add a shader to the layer.</p> <p>Parameters:</p> <ul> <li> <code>shader</code>               (<code>str</code>)           \u2013            <p>The shader to add.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.AnnotationLayer.apply_to_neuroglancer","title":"<code>apply_to_neuroglancer(viewer)</code>","text":"<p>Can be a viewer or a viewer.txn()-context state</p>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.AnnotationLayer.set_linked_segmentation","title":"<code>set_linked_segmentation(layer)</code>","text":"<p>Add a linked segmentation layer to the annotation layer.</p> <p>Parameters:</p> <ul> <li> <code>layer</code>               (<code>str or SegmentationLayer</code>)           \u2013            <p>The linked segmentation layer or the string value of its name.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.CoordSpace","title":"<code>CoordSpace</code>","text":"<p>Coordinate space for Neuroglancer.</p> <p>Parameters:</p> <ul> <li> <code>resolution</code>               (<code>list[int]</code>)           \u2013            <p>The resolution of the coordinate space. Default is None, which will raise an error if not set.</p> </li> <li> <code>units</code>               (<code>str or list[str]</code>)           \u2013            <p>The units of the coordinate space. Default is \"nm\". If a single string is provided, it will be repeated for each dimension.</p> </li> <li> <code>names</code>               (<code>list[str]</code>)           \u2013            <p>The names of the dimensions. Default is [\"x\", \"y\", \"z\"]. If the length of names does not match the length of resolution, an error will be raised.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.CoordSpaceTransform","title":"<code>CoordSpaceTransform</code>","text":"<p>Coordinate space transform for Neuroglancer.</p> <p>Parameters:</p> <ul> <li> <code>output_dimensions</code>               (<code>list[int] or CoordSpace</code>)           \u2013            <p>The output dimensions of the transform. If a list, it will be converted to a CoordSpace. Default is None, which will create a transform with no output dimensions.</p> </li> <li> <code>input_dimensions</code>               (<code>list[int] or CoordSpace</code>)           \u2013            <p>The input dimensions of the transform. If a list, it will be converted to a CoordSpace. Default is None, which will create a transform with no input dimensions.</p> </li> <li> <code>matrix</code>               (<code>list[list[float]]</code>)           \u2013            <p>The transformation matrix. Default is None, which will create an identity matrix. The matrix should be a 4x4 list of lists, where the last row is [0, 0, 0, 1]. If None, an identity matrix will be created based on the output dimensions.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.DataMap","title":"<code>DataMap</code>","text":"<p>Class to defer mapping of dataframes to a ViewerState or Layer.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to use for the datamap, which is used to label data when using the <code>map</code> or <code>with_map</code> classes. If no key is provided, a default key of \"None\" is used and assumed if no dictionary is provided later.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.ImageLayer","title":"<code>ImageLayer</code>","text":"<p>               Bases: <code>LayerWithSource</code></p> <p>Configuration for a Neuroglancer image layer.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the layer. Default is \"img\".</p> </li> <li> <code>source</code>               (<code>Source or list of Source</code>)           \u2013            <p>The source of the image data. Can be a Source object or a list of Source objects.</p> </li> <li> <code>shader</code>               (<code>str</code>)           \u2013            <p>The shader to use for rendering the image. Default is None, which will use the default shader.</p> </li> <li> <code>color</code>               (<code>list</code>)           \u2013            <p>The color to use for the image layer. Default is None, which will use the default color.</p> </li> <li> <code>opacity</code>               (<code>float</code>)           \u2013            <p>The opacity of the image layer. Default is 1.0.</p> </li> <li> <code>blend</code>               (<code>str</code>)           \u2013            <p>The blending mode for the image layer. Default is None, which will use the default blend mode.</p> </li> <li> <code>volume_rendering_mode</code>               (<code>str</code>)           \u2013            <p>The volume rendering mode for the image layer. Default is None, which will use the default mode.</p> </li> <li> <code>volume_rendering_gain</code>               (<code>float</code>)           \u2013            <p>The gain for volume rendering. Default is None, which will use the default gain.</p> </li> <li> <code>volume_rendering_depth_samples</code>               (<code>int</code>)           \u2013            <p>The number of depth samples for volume rendering. Default is None, which will use the default number of samples.</p> </li> <li> <code>cross_section_render_scale</code>               (<code>float</code>)           \u2013            <p>The scale for cross-section rendering. Default is None, which will use the default scale.</p> </li> <li> <code>pick</code>           \u2013            <p>Whether to allow cursor interaction with meshes and skeletons. Default is True.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>add_from_client</code>             \u2013              <p>Add an image layer source from caveclient.</p> </li> <li> <code>add_shader</code>             \u2013              <p>Add a shader to the layer.</p> </li> <li> <code>apply_to_neuroglancer</code>             \u2013              <p>Can be a viewer or a viewer.txn()-context state</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.ImageLayer.add_from_client","title":"<code>add_from_client(client)</code>","text":"<p>Add an image layer source from caveclient.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>CAVEclient</code>)           \u2013            <p>The CAVEclient object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImageLayer</code>           \u2013            <p>An ImageLayer object.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.ImageLayer.add_shader","title":"<code>add_shader(shader)</code>","text":"<p>Add a shader to the layer.</p> <pre><code>Parameters\n</code></pre> <pre><code>shader : str\n    The shader to add.\n</code></pre>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.ImageLayer.add_shader--_1","title":"statebuilder.ngl_components","text":""},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.ImageLayer.apply_to_neuroglancer","title":"<code>apply_to_neuroglancer(viewer)</code>","text":"<p>Can be a viewer or a viewer.txn()-context state</p>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.Layer","title":"<code>Layer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>map</code>             \u2013              <p>Map the layer to a datamap.</p> </li> <li> <code>to_dict</code>             \u2013              <p>Convert the layer to a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>is_static</code>               (<code>bool</code>)           \u2013            <p>Check if the layer is static.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.Layer.is_static","title":"<code>is_static</code>  <code>property</code>","text":"<p>Check if the layer is static.</p>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.Layer.map","title":"<code>map(datamap, inplace=False)</code>","text":"<p>Map the layer to a datamap.</p> <p>Parameters:</p> <ul> <li> <code>datamap</code>               (<code>dict</code>)           \u2013            <p>The datamap to map the layer to.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to modify the layer in place or return a new layer. Default is False.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.Layer.to_dict","title":"<code>to_dict(with_name=True)</code>","text":"<p>Convert the layer to a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>with_name</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include the name, visibility, and archived states of the layer in the dictionary, by default True. These are not typically included until the layer is part of a state, but adding them in allows the resulting data to be passed to a viewer state string.</p> </li> <li> <code>datamap</code>           \u2013            <p>A dictionary with keys being names of DataMap parameters and values being the data to be passed. Must be provided if the layer has any datamaps registered.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>The layer as a dictionary.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.LayerWithSource","title":"<code>LayerWithSource</code>","text":"<p>               Bases: <code>Layer</code></p> <p>Methods:</p> <ul> <li> <code>add_source</code>             \u2013              <p>Add a source to the layer.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.LayerWithSource.add_source","title":"<code>add_source(source, resolution=None)</code>","text":"<p>Add a source to the layer.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>str or Source</code>)           \u2013            <p>The source to add.</p> </li> <li> <code>resolution</code>               (<code>list or ArrayLike</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the source. Default is None.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.RawLayer","title":"<code>RawLayer</code>","text":"<p>               Bases: <code>Layer</code></p> <p>Configuration for a Neuroglancer raw layer from a data source</p> <p>Methods:</p> <ul> <li> <code>remap_sources</code>             \u2013              <p>Remap the sources in the layer's JSON data using the provided source map.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.RawLayer.remap_sources","title":"<code>remap_sources(source_map)</code>","text":"<p>Remap the sources in the layer's JSON data using the provided source map.</p> <p>Parameters:</p> <ul> <li> <code>source_map</code>               (<code>dict</code>)           \u2013            <p>A mapping from old source paths to new source identifiers.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The updated layer with remapped sources.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.SegmentationLayer","title":"<code>SegmentationLayer</code>","text":"<p>               Bases: <code>LayerWithSource</code></p> <p>Configuration for a Neuroglancer segmentation layer.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the layer. Default is \"seg\".</p> </li> <li> <code>source</code>               (<code>Source or str</code>)           \u2013            <p>The source of the segmentation data. Can be a Source object or a string URL.</p> </li> <li> <code>segments</code>               (<code>list or dict or VisibleSegments</code>)           \u2013            <p>The segments to display in the layer. Can be a list of segment IDs, a dictionary with segment IDs as keys and visibility as values, or a VisibleSegments object.</p> </li> <li> <code>color</code>               (<code>list</code>)           \u2013            <p>The color to use for the segments. Default is None, which will use the default color.</p> </li> <li> <code>hide_segment_zero</code>               (<code>bool</code>)           \u2013            <p>Whether to hide segment zero, which is typically treated as \"no segmentation\". Default is True.</p> </li> <li> <code>selected_alpha</code>               (<code>float</code>)           \u2013            <p>The transparency value for selected segments in the 2d views. Default is 0.2.</p> </li> <li> <code>not_selected_alpha</code>               (<code>float</code>)           \u2013            <p>The transparency value for unselected segments in the 2d views. Default is 0.0.</p> </li> <li> <code>alpha_3d</code>               (<code>float</code>)           \u2013            <p>The transparency value for segments in the 3d view. Default is 0.9.</p> </li> <li> <code>mesh_silhouette</code>               (<code>float</code>)           \u2013            <p>The silhouette rendering value for the mesh. Default is 0.0.</p> </li> <li> <code>segment_colors</code>               (<code>dict</code>)           \u2013            <p>A dictionary mapping segment IDs to colors. Default is None, which will use the default colors.</p> </li> <li> <code>shader</code>               (<code>str</code>)           \u2013            <p>The shader to use for rendering the skeletons if a skeleton source is provided. Default is None, which will use the default shader.</p> </li> <li> <code>pick</code>           \u2013            <p>Whether to allow cursor interaction with meshes and skeletons. Default is True.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>add_default_skeleton_shader</code>             \u2013              <p>Add a default skeleton shader with desaturated axons to the layer.</p> </li> <li> <code>add_from_client</code>             \u2013              <p>Add a segmentation layer source from caveclient.</p> </li> <li> <code>add_segment_colors</code>             \u2013              <p>Add segment colors to the layer.</p> </li> <li> <code>add_segment_properties</code>             \u2013              <p>Upload segment properties and add to the layer.</p> </li> <li> <code>add_segments</code>             \u2013              <p>Add segment ids to the layer.</p> </li> <li> <code>add_segments_from_data</code>             \u2013              <p>Create a SegmentationLayer from a DataFrame.</p> </li> <li> <code>add_shader</code>             \u2013              <p>Add a shader to the layer.</p> </li> <li> <code>apply_to_neuroglancer</code>             \u2013              <p>Can be a viewer or a viewer.txn()-context state</p> </li> <li> <code>set_view_options</code>             \u2013              <p>Set the view options for the layer.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.SegmentationLayer.add_default_skeleton_shader","title":"<code>add_default_skeleton_shader()</code>","text":"<p>Add a default skeleton shader with desaturated axons to the layer.</p>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.SegmentationLayer.add_from_client","title":"<code>add_from_client(client, add_skeleton_source=True)</code>","text":"<p>Add a segmentation layer source from caveclient.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>CAVEclient</code>)           \u2013            <p>The CAVEclient object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationLayer</code>           \u2013            <p>A SegmentationLayer object.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.SegmentationLayer.add_segment_colors","title":"<code>add_segment_colors(segment_colors)</code>","text":"<p>Add segment colors to the layer.</p> <p>Parameters:</p> <ul> <li> <code>segment_colors</code>               (<code>dict</code>)           \u2013            <p>The segment colors to add.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationLayer</code>           \u2013            <p>The SegmentationLayer object with the added segment colors.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.SegmentationLayer.add_segment_properties","title":"<code>add_segment_properties(data, client, id_column='pt_root_id', label_column=None, description_column=None, string_columns=None, number_columns=None, tag_value_columns=None, tag_bool_columns=None, tag_descriptions=None, allow_disambiguation=True, label_separator='_', label_format_map=None, prepend_col_name=False, random_columns=None, random_column_prefix=None, dry_run=False)</code>","text":"<p>Upload segment properties and add to the layer. If you already have a segment properties cloud path, use <code>add_source</code> to add it to the layer.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>The DataFrame containing the segment properties.</p> </li> <li> <code>client</code>               (<code>CAVEclient</code>)           \u2013            <p>The CAVEclient object needed to upload .</p> </li> <li> <code>id_column</code>               (<code>str</code>, default:                   <code>'pt_root_id'</code> )           \u2013            <p>The column name for the segment IDs. Default is 'pt_root_id'.</p> </li> <li> <code>label_column</code>               (<code>str or list</code>, default:                   <code>None</code> )           \u2013            <p>The column name(s) for the segment labels. Default is None.</p> </li> <li> <code>description_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the segment descriptions. Default is None.</p> </li> <li> <code>string_columns</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The column names for string properties. Default is None.</p> </li> <li> <code>number_columns</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The column names for number properties. Default is None.</p> </li> <li> <code>tag_value_columns</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The column names for tag value properties. Default is None.</p> </li> <li> <code>tag_bool_columns</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The column names for tag boolean properties. Default is None.</p> </li> <li> <code>tag_descriptions</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The descriptions for the tags. Default is None.</p> </li> <li> <code>allow_disambiguation</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to allow disambiguation of segment IDs. Default is True.</p> </li> <li> <code>label_separator</code>               (<code>str</code>, default:                   <code>'_'</code> )           \u2013            <p>The separator for label formatting. Default is \"_\".</p> </li> <li> <code>label_format_map</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The format map for labels. Default is None.</p> </li> <li> <code>prepend_col_name</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to prepend the column name to the label. Default is False.</p> </li> <li> <code>random_columns</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Number of random columns to add. Default is None.</p> </li> <li> <code>random_column_prefix</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name prefix of the random columns. Default is None.</p> </li> <li> <code>dry_run</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If dry run is true, build but do not actually upload and instead use a placeholder source text. Default is False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationLayer</code>           \u2013            <p>A SegmentationLayer object with added segment properties.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.SegmentationLayer.add_segments","title":"<code>add_segments(segments, visible=None)</code>","text":"<p>Add segment ids to the layer.</p> <p>Parameters:</p> <ul> <li> <code>segments</code>               (<code>list or dict or VisibleSegments</code>)           \u2013            <p>The segments to add. If a dict, the keys are the segment IDs and the values are the boolean visibility.</p> </li> <li> <code>visible</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>The visibility of the segments, assumed to be True if not provided. Should be the same length as segments, and segments should be a list of the same length.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationLayer</code>           \u2013            <p>The SegmentationLayer object.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.SegmentationLayer.add_segments_from_data","title":"<code>add_segments_from_data(data, segment_column, visible_column=None, color_column=None)</code>","text":"<p>Create a SegmentationLayer from a DataFrame.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>The DataFrame containing the segmentation data.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the layer. Default is \"seg\".</p> </li> <li> <code>color</code>               (<code>str</code>)           \u2013            <p>The color to use.</p> </li> <li> <code>shader</code>               (<code>str</code>)           \u2013            <p>The shader to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationLayer</code>           \u2013            <p>A SegmentationLayer object.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.SegmentationLayer.add_shader","title":"<code>add_shader(shader)</code>","text":"<p>Add a shader to the layer.</p> <p>Parameters:</p> <ul> <li> <code>shader</code>               (<code>str</code>)           \u2013            <p>The shader to add.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.SegmentationLayer.apply_to_neuroglancer","title":"<code>apply_to_neuroglancer(viewer)</code>","text":"<p>Can be a viewer or a viewer.txn()-context state</p>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.SegmentationLayer.set_view_options","title":"<code>set_view_options(selected_alpha=None, not_selected_alpha=None, alpha_3d=None, mesh_silhouette=None)</code>","text":"<p>Set the view options for the layer.</p> <p>Parameters:</p> <ul> <li> <code>selected_alpha</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The alpha value for selected segments. Default is 0.2.</p> </li> <li> <code>not_selected_alpha</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The alpha value for not selected segments. Default is 0.0.</p> </li> <li> <code>alpha_3d</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The alpha value for 3D segments. Default is 0.9.</p> </li> <li> <code>mesh_silhouette</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The silhouette value for the mesh. Default is 0.0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationLayer</code>           \u2013            <p>A SegmentationLayer object with updated view options.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.Source","title":"<code>Source</code>","text":"<p>Configuration for a Neuroglancer data source.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The URL of the data source.</p> </li> <li> <code>resolution</code>               (<code>list</code>)           \u2013            <p>The resolution of the data source. Default is None.</p> </li> <li> <code>transform</code>               (<code>CoordSpaceTransform</code>)           \u2013            <p>The coordinate space transform for the data source. Default is None, which will create a transform based on the resolution.</p> </li> <li> <code>subsources</code>               (<code>dict</code>)           \u2013            <p>A dictionary of subsources for the data source (e.g. meshes, skeletons, etc). Default is None, which includes all subsources.</p> </li> <li> <code>enable_default_subsources</code>               (<code>bool</code>)           \u2013            <p>Whether to enable default subsources. Default is True, which includes all default subsources.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>to_neuroglancer</code>             \u2013              <p>Convert the Source to a neuroglancer-python object.</p> </li> </ul>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.Source.to_neuroglancer","title":"<code>to_neuroglancer()</code>","text":"<p>Convert the Source to a neuroglancer-python object.</p>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.UnmappedDataError","title":"<code>UnmappedDataError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a layer is not fully mapped to a datamap.</p>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.segments_to_neuroglancer","title":"<code>segments_to_neuroglancer(segments)</code>","text":"<p>Convert a flat or mixed-visibility segment list to Neuroglancer.</p>"},{"location":"reference/ngl_components/#src.nglui.statebuilder.ngl_components.source_to_neuroglancer","title":"<code>source_to_neuroglancer(source, resolution=None, image_layer=False)</code>","text":"<p>Convert a possibly multi-url source to a Neuroglancer-compatible format.</p>"},{"location":"reference/parser/","title":"parser","text":"<p>Modules:</p> <ul> <li> <code>base</code>           \u2013            </li> <li> <code>info</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>StateParser</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>annotation_dataframe</code>             \u2013              <p>Return a dataframe with all annotations across all annotation layers in the state.</p> </li> <li> <code>annotation_layers</code>             \u2013              <p>Get all annotation layer names in the state</p> </li> <li> <code>bbox_annotations</code>             \u2013              <p>Get all bounding box annotation points and other info from a layer.</p> </li> <li> <code>extract_multicut</code>             \u2013              <p>Extract information entered into the multicut graph operation</p> </li> <li> <code>get_layer</code>             \u2013              <p>Gets the contents of the layer based on the layer name.</p> </li> <li> <code>get_selected_ids</code>             \u2013              <p>Get a list of selected ids in a segmentation layer</p> </li> <li> <code>group_annotations</code>             \u2013              <p>All group annotations and their associated points</p> </li> <li> <code>image_layers</code>             \u2013              <p>Get all image layer names in the state</p> </li> <li> <code>layer_dataframe</code>             \u2013              <p>Return a dataframe with a row for each layer in the state.</p> </li> <li> <code>layer_names</code>             \u2013              <p>Get all layer names in the state</p> </li> <li> <code>layer_source</code>             \u2013              <p>Get url source or list of sources for a layer</p> </li> <li> <code>line_annotations</code>             \u2013              <p>Get all line annotation points and other info from a layer.</p> </li> <li> <code>point_annotations</code>             \u2013              <p>Get all point annotation points and other info from a layer.</p> </li> <li> <code>segmentation_layers</code>             \u2013              <p>Get all segmentation layer names in the state</p> </li> <li> <code>selection_dataframe</code>             \u2013              <p>Return a dataframe with a row for each selected id across segmentation layers.</p> </li> <li> <code>sphere_annotations</code>             \u2013              <p>Get all sphere annotation points and other info from a layer.</p> </li> <li> <code>tag_dictionary</code>             \u2013              <p>Get the tag id to string dictionary for a layer</p> </li> <li> <code>view_settings</code>             \u2013              <p>Get all data about the view state in neuroglancer: position,</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.StateParser","title":"<code>StateParser(state)</code>","text":"<p>Convenience class for parsing neuroglancer states.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state as a JSON dict</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>annotation_dataframe</code>             \u2013              <p>Get a dataframe with all annotations across all annotation layers in the state.</p> </li> <li> <code>layer_dataframe</code>             \u2013              <p>Get a dataframe with a row for each layer in the state.</p> </li> <li> <code>selection_dataframe</code>             \u2013              <p>Get a dataframe with a row for each selected id across segmentation layers.</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.StateParser.annotation_dataframe","title":"<code>annotation_dataframe(expand_tags=False, point_resolution=None, split_points=False, include_archived=True)</code>","text":"<p>Get a dataframe with all annotations across all annotation layers in the state.</p> <p>Parameters:</p> <ul> <li> <code>expand_tags</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, expand tags into separate boolean columns named by the tag label. By default False. Note that if tag labels are duplicated in multiple layers, the values will appear in the same column.</p> </li> <li> <code>point_resolution</code>               (<code>Tuple[float, float, float]</code>, default:                   <code>None</code> )           \u2013            <p>If provided, points will be rescaled to the provided x, y, z resolution (in nanometers). By default None.</p> </li> <li> <code>split_points</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, points will be split into separate x, y, z columns. By default False.</p> </li> <li> <code>include_archived</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, include archived layers. By default True</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Dataframe with columns layer, anno_type, point, pointB, linked_segmentation, tags, anno_id, group_id, description. If expand_tags is True, an additional column will be added for each tag.</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.StateParser.layer_dataframe","title":"<code>layer_dataframe(include_archived=True)</code>","text":"<p>Get a dataframe with a row for each layer in the state.</p> <p>Parameters:</p> <ul> <li> <code>include_archived</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, include archived layers. By default True</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Dataframe with columns layer, type, source containing layer information.</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.StateParser.selection_dataframe","title":"<code>selection_dataframe(include_archived=True)</code>","text":"<p>Get a dataframe with a row for each selected id across segmentation layers.</p> <p>Parameters:</p> <ul> <li> <code>include_archived</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, include archived layers. By default True</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Dataframe with columns: layer, id, visible Visible only applies in Spelunker states.</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.annotation_dataframe","title":"<code>annotation_dataframe(state, expand_tags=False, point_resolution=None, split_points=False, include_archived=True)</code>","text":"<p>Return a dataframe with all annotations across all annotation layers in the state.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state dictionary</p> </li> <li> <code>expand_tags</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, expand tags into separate boolean columns named by the tag label. By default False. Note that if tag labels are duplicated in multiple layers, the values will appear in the same column.</p> </li> <li> <code>point_resolution</code>               (<code>Tuple[float, float, float]</code>, default:                   <code>None</code> )           \u2013            <p>If provided, points will be rescaled to the provided x, y, z resolution (in nanometers). By default None.</p> </li> <li> <code>split_points</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, points will be split into separate x, y, z columns. By default False.</p> </li> <li> <code>include_archived</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, include archived layers. By default True</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Dataframe with columns layer, anno_type, point, pointB, linked_segmentation, tags, anno_id, group_id, description. If expand_tags is True, an additional column will be added for each tag.</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.annotation_layers","title":"<code>annotation_layers(state, include_archived=True)</code>","text":"<p>Get all annotation layer names in the state</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state as a JSON dict</p> </li> <li> <code>include_archived</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, include archived layers. By default True</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>names</code> (              <code>list</code> )          \u2013            <p>List of layer names</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.bbox_annotations","title":"<code>bbox_annotations(state, layer_name, description=False, linked_segmentations=False, tags=False, group=False)</code>","text":"<p>Get all bounding box annotation points and other info from a layer.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state as JSON dict</p> </li> <li> <code>layer_name</code>               (<code>str</code>)           \u2013            <p>Layer name</p> </li> <li> <code>description</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also returns descriptions as well. By default False</p> </li> <li> <code>linked_segmentations</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also returns list of linked segmentations, by default False</p> </li> <li> <code>tags</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also returns list of tags, by default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>anno_points_A</code> (              <code>list</code> )          \u2013            <p>List of N 3-element points (as list) of the first point in each bbox.</p> </li> <li> <code>anno_points_B</code> (              <code>list</code> )          \u2013            <p>List of N 3-element points (as list) of the second point in each bbox.</p> </li> <li> <code>anno_descriptions</code> (              <code>list</code> )          \u2013            <p>List of N strings (or None), only returned if description=True.</p> </li> <li> <code>anno_linked_segmentations</code> (              <code>list</code> )          \u2013            <p>List of N lists of object ids. Only returned if linked_segmentations=True.</p> </li> <li> <code>anno_tags</code> (              <code>list</code> )          \u2013            <p>List of N lists of tag ids. Only returned if tags=True.</p> </li> <li> <code>anno_group</code> (              <code>list</code> )          \u2013            <p>List of group ids (as string) or None for annotations. Only returned if group=True</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.extract_multicut","title":"<code>extract_multicut(state, seg_layer=None)</code>","text":"<p>Extract information entered into the multicut graph operation</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state</p> </li> <li> <code>seg_layer</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name of a segmentation layer or None. If None, the function will check how many segmentation layers there are and, if only one exits, choose it. If more than one segmentation layer is present, it errors. By default None</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>pts</code> (              <code>array</code> )          \u2013            <p>Nx3 array of points selected</p> </li> <li> <code>side</code> (              <code>array</code> )          \u2013            <p>N array with 'source' or 'sink', depending on which side the point is on.</p> </li> <li> <code>svids</code> (              <code>array</code> )          \u2013            <p>N array with selected supervoxel. If only points are selected (e.g. via clicking on the mesh), the value will be NaN.</p> </li> <li> <code>root_id</code> (              <code>int</code> )          \u2013            <p>Root id of the object to split</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.get_layer","title":"<code>get_layer(state, layer_name)</code>","text":"<p>Gets the contents of the layer based on the layer name.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state as a JSON dict</p> </li> <li> <code>layer_name</code>               (<code>str</code>)           \u2013            <p>Name of layer</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>layer</code> (              <code>dict</code> )          \u2013            <p>Layer data contents</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.get_selected_ids","title":"<code>get_selected_ids(state, layer=None, return_nonvisible=False)</code>","text":"<p>Get a list of selected ids in a segmentation layer</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>State dict</p> </li> <li> <code>layer</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Segmentation layer name, if needed. If None and only one segmentation layer is present, default to it. By default None</p> </li> <li> <code>return_nonvisible</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also return non-visible ids. By default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>List of root ids.</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.group_annotations","title":"<code>group_annotations(state, layer_name, description=False, linked_segmentations=False, tags=False)</code>","text":"<p>All group annotations and their associated points</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state as JSON dict</p> </li> <li> <code>layer_name</code>               (<code>str</code>)           \u2013            <p>Annotation layer name</p> </li> <li> <code>description</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also returns descriptions as well. By default False</p> </li> <li> <code>linked_segmentations</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also returns list of linked segmentations, by default False</p> </li> <li> <code>tags</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also returns list of tags, by default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>group_points</code> (              <code>list</code> )          \u2013            <p>List of N 3-element points</p> </li> <li> <code>group_id</code> (              <code>list</code> )          \u2013            <p>List of N id strings for groups.</p> </li> <li> <code>anno_descriptions</code> (              <code>list</code> )          \u2013            <p>List of N strings (or None), only returned if description=True.</p> </li> <li> <code>anno_linked_segmentations</code> (              <code>list</code> )          \u2013            <p>List of N lists of object ids. Only returned if linked_segmentations=True.</p> </li> <li> <code>anno_tags</code> (              <code>list</code> )          \u2013            <p>List of N lists of tag ids. Only returned if tags=True.</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.image_layers","title":"<code>image_layers(state, include_archived=True)</code>","text":"<p>Get all image layer names in the state</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state as a JSON dict</p> </li> <li> <code>include_archived</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, include archived layers. By default True</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>names</code> (              <code>list</code> )          \u2013            <p>List of layer names</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.layer_dataframe","title":"<code>layer_dataframe(state, include_archived=True)</code>","text":"<p>Return a dataframe with a row for each layer in the state.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state</p> </li> <li> <code>include_archived</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, include archived layers. By default True</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Dataframe with columns layer, type, source</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.layer_names","title":"<code>layer_names(state, include_archived=True)</code>","text":"<p>Get all layer names in the state</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state as a JSON dict</p> </li> <li> <code>include_archived</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, include archived layers. By default True</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>names</code> (              <code>list</code> )          \u2013            <p>List of layer names</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.layer_source","title":"<code>layer_source(state, layer_name)</code>","text":"<p>Get url source or list of sources for a layer</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state as a JSON dict</p> </li> <li> <code>layer_name</code>               (<code>str</code>)           \u2013            <p>Name of layer</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>URL source or list of URL sources</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.line_annotations","title":"<code>line_annotations(state, layer_name, description=False, linked_segmentations=False, tags=False, group=False)</code>","text":"<p>Get all line annotation points and other info from a layer.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state as JSON dict</p> </li> <li> <code>layer_name</code>               (<code>str</code>)           \u2013            <p>Layer name</p> </li> <li> <code>description</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also returns descriptions as well. By default False</p> </li> <li> <code>linked_segmentations</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also returns list of linked segmentations, by default False</p> </li> <li> <code>tags</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also returns list of tags, by default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>anno_points_A</code> (              <code>list</code> )          \u2013            <p>List of N 3-element points (as list) of the first point in each line.</p> </li> <li> <code>anno_points_B</code> (              <code>list</code> )          \u2013            <p>List of N 3-element points (as list) of the second point in each line.</p> </li> <li> <code>anno_descriptions</code> (              <code>list</code> )          \u2013            <p>List of N strings (or None), only returned if description=True.</p> </li> <li> <code>anno_linked_segmentations</code> (              <code>list</code> )          \u2013            <p>List of N lists of object ids. Only returned if linked_segmentations=True.</p> </li> <li> <code>anno_tags</code> (              <code>list</code> )          \u2013            <p>List of N lists of tag ids. Only returned if tags=True.</p> </li> <li> <code>anno_group</code> (              <code>list</code> )          \u2013            <p>List of group ids (as string) or None for annotations. Only returned if group=True</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.point_annotations","title":"<code>point_annotations(state, layer_name, description=False, linked_segmentations=False, tags=False, group=False)</code>","text":"<p>Get all point annotation points and other info from a layer.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state as JSON dict</p> </li> <li> <code>layer_name</code>               (<code>str</code>)           \u2013            <p>Layer name</p> </li> <li> <code>description</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also returns descriptions as well. By default False</p> </li> <li> <code>linked_segmentations</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also returns list of linked segmentations, by default False</p> </li> <li> <code>tags</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also returns list of tags, by default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>anno_points</code> (              <code>list</code> )          \u2013            <p>List of N 3-element points (as list)</p> </li> <li> <code>anno_descriptions</code> (              <code>list</code> )          \u2013            <p>List of N strings (or None), only returned if description=True.</p> </li> <li> <code>anno_linked_segmentations</code> (              <code>list</code> )          \u2013            <p>List of N lists of object ids. Only returned if linked_segmentations=True.</p> </li> <li> <code>anno_tags</code> (              <code>list</code> )          \u2013            <p>List of N lists of tag ids. Only returned if tags=True.</p> </li> <li> <code>anno_group</code> (              <code>list</code> )          \u2013            <p>List of group ids (as string) or None for annotations. Only returned if group=True</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.segmentation_layers","title":"<code>segmentation_layers(state, include_archived=True)</code>","text":"<p>Get all segmentation layer names in the state</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state as a JSON dict</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>names</code> (              <code>list</code> )          \u2013            <p>List of layer names</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.selection_dataframe","title":"<code>selection_dataframe(state, include_archived=True)</code>","text":"<p>Return a dataframe with a row for each selected id across segmentation layers.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state</p> </li> <li> <code>include_archived</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, include archived layers. By default True</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Dataframe with columns: layer, id, visible Visible only applies in Spelunker states.</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.sphere_annotations","title":"<code>sphere_annotations(state, layer_name, description=False, linked_segmentations=False, tags=False, group=False)</code>","text":"<p>Get all sphere annotation points and other info from a layer.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state as JSON dict</p> </li> <li> <code>layer_name</code>               (<code>str</code>)           \u2013            <p>Layer name</p> </li> <li> <code>description</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also returns descriptions as well. By default False</p> </li> <li> <code>linked_segmentations</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also returns list of linked segmentations, by default False</p> </li> <li> <code>tags</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also returns list of tags, by default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>anno_points</code> (              <code>list</code> )          \u2013            <p>List of N 3-element center points (as list)</p> </li> <li> <code>radius_points</code> (              <code>list</code> )          \u2013            <p>List of N 3-element radii for each axis of the ellipsoid.</p> </li> <li> <code>anno_descriptions</code> (              <code>list</code> )          \u2013            <p>List of N strings (or None), only returned if description=True.</p> </li> <li> <code>anno_linked_segmentations</code> (              <code>list</code> )          \u2013            <p>List of N lists of object ids. Only returned if linked_segmentations=True.</p> </li> <li> <code>anno_tags</code> (              <code>list</code> )          \u2013            <p>List of N lists of tag ids. Only returned if tags=True.</p> </li> <li> <code>anno_group</code> (              <code>list</code> )          \u2013            <p>List of group ids (as string) or None for annotations. Only returned if group=True</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.tag_dictionary","title":"<code>tag_dictionary(state, layer_name)</code>","text":"<p>Get the tag id to string dictionary for a layer</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            </li> <li> <code>layer_name</code>               (<code>[type]</code>)           \u2013            <p>[description]</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>[type]</code>           \u2013            <p>[description]</p> </li> </ul>"},{"location":"reference/parser/#src.nglui.parser.view_settings","title":"<code>view_settings(state)</code>","text":"<p>Get all data about the view state in neuroglancer: position, image zoom, orientation and zoom of the 3d view, and voxel size.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict</code>)           \u2013            <p>Neuroglancer state as JSON dict</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>view</code> (              <code>dict</code> )          \u2013            <p>Dictionary with keys: position, zoomFactor, perspectiveOrientation, perspectiveZoom, and voxelSize</p> </li> </ul>"},{"location":"reference/segmentprops/","title":"segmentprops","text":"<p>Note</p> <p>Autogeneration of the function reference does not capture the full range of segment properties. Please see the documentation for the individual segment types if you want to build segment properties manually.</p> <p>Classes:</p> <ul> <li> <code>SegmentProperties</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>prop_filter</code>             \u2013              <p>Filters out None for optional attributes for use in 'attrs.asdict' conversion</p> </li> </ul>"},{"location":"reference/segmentprops/#src.nglui.segmentprops.base.SegmentProperties","title":"<code>SegmentProperties(ids, label_property=None, description_property=None, tag_properties=None, string_properties=None, number_properties=None)</code>","text":"<p>Methods:</p> <ul> <li> <code>from_dataframe</code>             \u2013              <p>Generate a segment property object from a pandas dataframe based on column</p> </li> <li> <code>from_dict</code>             \u2013              <p>Generate a segment property object from a segment property dictionary</p> </li> <li> <code>to_dataframe</code>             \u2013              <p>Converts the segment properties to a pandas dataframe</p> </li> <li> <code>to_dict</code>             \u2013              <p>Converts the segment properties to a dictionary for use in neuroglancer</p> </li> </ul>"},{"location":"reference/segmentprops/#src.nglui.segmentprops.base.SegmentProperties.from_dataframe","title":"<code>from_dataframe(df, id_col='pt_root_id', label_col=None, description_col=None, string_cols=None, number_cols=None, tag_value_cols=None, tag_bool_cols=None, tag_descriptions=None, allow_disambiguation=True, label_separator='_', label_format_map=None, prepend_col_name=False, random_columns=None, random_column_prefix='random_sample')</code>  <code>classmethod</code>","text":"<p>Generate a segment property object from a pandas dataframe based on column</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>Dataframe containing propeties</p> </li> <li> <code>id_col</code>               (<code>str</code>, default:                   <code>'pt_root_id'</code> )           \u2013            <p>Name of the column with object ids, by default \"pt_root_id\"</p> </li> <li> <code>label_col</code>               (<code>Optional[str, list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Name of column or columns to use for producing labels, by default None. If multiple columns are provided, they will be concatenated with the label_separator. Null values are skipped.</p> </li> <li> <code>description_col</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Name of column to use for producing descriptions, by default None</p> </li> <li> <code>string_cols</code>               (<code>Optional[Union[str, list[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>Column (or list of columns) to use for string properties, by default None.</p> </li> <li> <code>number_cols</code>               (<code>Optional[Union[str, list[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>Column (or list of columns) to use for numeric properties, by default None.</p> </li> <li> <code>tag_value_cols</code>               (<code>Optional[list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Column (or list of columns) to generate tags based on unique values. Each column produces one tag per row based on the value, by default None</p> </li> <li> <code>tag_bool_cols</code>               (<code>Optional[list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>List of columns to generate tags based on boolean values where each column is a tag, and each id gets the tag if it has a True in its row. By default None.</p> </li> <li> <code>tag_descriptions</code>               (<code>Optional[dict]</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of tag values to long-form tag descriptions, by default None. Tags without a key/value are passed through directly.</p> </li> <li> <code>allow_disambiguation</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, will prepend the column name in the case of duplicate tags, by default True.</p> </li> <li> <code>label_separator</code>               (<code>str</code>, default:                   <code>'_'</code> )           \u2013            <p>Separator to use when assembling multiple columns into a label, by default \"_\"</p> </li> <li> <code>label_format_map</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Format string to use for label formatting, by default None. If provided, will override the label separator and use the format string to format the label via the \"format\" function, replacing the column names in <code>{..}</code> with the values. For example, \"{cell_class}: {cell_type}_{region}\" would pluck values from the columns \"cell_class\", \"cell_type\", and \"region\". Label columns will be ignored and the format string is not validated.</p> </li> <li> <code>prepend_col_name</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, will prepend the column name to tag values, by default False. This will effectively disambiguate all tags as well.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentProperties</code>           \u2013            <p>Segment properties object</p> </li> </ul>"},{"location":"reference/segmentprops/#src.nglui.segmentprops.base.SegmentProperties.from_dict","title":"<code>from_dict(seg_prop_dict)</code>  <code>classmethod</code>","text":"<p>Generate a segment property object from a segment property dictionary</p> <p>Parameters:</p> <ul> <li> <code>seg_prop_dict</code>               (<code>dict</code>)           \u2013            <p>Segment property dictionary, as imported from the json.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentProperties</code>           \u2013            <p>Segment properties object</p> </li> </ul>"},{"location":"reference/segmentprops/#src.nglui.segmentprops.base.SegmentProperties.to_dataframe","title":"<code>to_dataframe()</code>","text":"<p>Converts the segment properties to a pandas dataframe</p>"},{"location":"reference/segmentprops/#src.nglui.segmentprops.base.SegmentProperties.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the segment properties to a dictionary for use in neuroglancer</p>"},{"location":"reference/segmentprops/#src.nglui.segmentprops.base.prop_filter","title":"<code>prop_filter(attr, value)</code>","text":"<p>Filters out None for optional attributes for use in 'attrs.asdict' conversion</p>"},{"location":"reference/shaders/","title":"statebuilder.shaders","text":"<p>Classes:</p> <ul> <li> <code>PointShader</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>color_to_vec3</code>             \u2013              <p>Convert a color to a string representation of an RGB triple.</p> </li> <li> <code>shader_base</code>             \u2013              <p>Set a skeleton vertex attribute in the shader code.</p> </li> <li> <code>simple_point_shader</code>             \u2013              <p>Generate a simple point shader with a specified color.</p> </li> </ul>"},{"location":"reference/shaders/#src.nglui.statebuilder.shaders.PointShader","title":"<code>PointShader(colors=None, colormap=None, n_colors=None, many_label_color='white', no_label_color='grey', markersize=5, markerslider=True)</code>","text":"<p>Create a point shader with customizable colors and properties. See https://jiffyclub.github.io/palettable/ for available colormaps.</p> <p>Parameters:</p> <ul> <li> <code>colors</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of colors (strings, hex, or RGB tuples/lists)</p> </li> <li> <code>colormap</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name of a palettable colormap (ignoring category) (e.g., 'Set1') Not used if colors is specified.</p> </li> <li> <code>n_colors</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of colors to extract from colormap. Cannot be more than the available numbers in the colormap. Only used if a colormap is specified.</p> </li> <li> <code>many_label_color</code>               (<code>str</code>, default:                   <code>'white'</code> )           \u2013            <p>Color for points with multiple labels, by default 'white'</p> </li> <li> <code>no_label_color</code>               (<code>str</code>, default:                   <code>'grey'</code> )           \u2013            <p>Color for points with no labels, by default 'grey'</p> </li> <li> <code>markersize</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Default marker size, by default 5</p> </li> <li> <code>markerslider</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include marker size slider, by default True</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>make_properties</code>             \u2013              <p>Return property configuration for neuroglancer.</p> </li> </ul>"},{"location":"reference/shaders/#src.nglui.statebuilder.shaders.PointShader.make_properties","title":"<code>make_properties()</code>","text":"<p>Return property configuration for neuroglancer.</p>"},{"location":"reference/shaders/#src.nglui.statebuilder.shaders.color_to_vec3","title":"<code>color_to_vec3(clr)</code>","text":"<p>Convert a color to a string representation of an RGB triple.</p> <p>:param clr: Color in various formats (string, tuple, list). :return: String representation of the RGB triple.</p>"},{"location":"reference/shaders/#src.nglui.statebuilder.shaders.shader_base","title":"<code>shader_base(vertex_attributes=None, checkbox_controls=None, sliders=None, defined_colors=None, uicontrols=None, body=None)</code>","text":"<p>Set a skeleton vertex attribute in the shader code.</p> <p>Parameters:</p> <ul> <li> <code>vertex_attributes</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>The names of the vertex attribute to set.</p> </li> <li> <code>checkbox_controls</code>               (<code>dict or list</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of checkbox controls with names as keys and default values as values. If a list is provided, it will be converted to a dictionary with True as default value.</p> </li> <li> <code>sliders</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of slider controls with names as keys and a tuple of (type, min, max, default) as values. If a list is provided, it will be converted to a dictionary with default values of float, 0, 1, 0.5.</p> </li> <li> <code>defined_colors</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of defined colors with names as keys and color values as values. If a list is provided, it will be converted to a dictionary with colors from the Tableau-10 palette.</p> </li> <li> <code>body</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The body of the shader code to execute in the main function. If none is provided, a simple emitRGB is given.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The shader code to set the vertex attribute.</p> </li> </ul>"},{"location":"reference/shaders/#src.nglui.statebuilder.shaders.simple_point_shader","title":"<code>simple_point_shader(color='tomato', markersize=5.0)</code>","text":"<p>Generate a simple point shader with a specified color.</p> <p>Parameters:</p> <ul> <li> <code>color</code>               (<code>str</code>, default:                   <code>'tomato'</code> )           \u2013            <p>Color for the points, by default 'tomato'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The shader code.</p> </li> </ul>"},{"location":"reference/site_utils/","title":"statebuilder.site_utils","text":"<p>Functions:</p> <ul> <li> <code>add_neuroglancer_site</code>             \u2013              <p>Add a neuroglancer site to the list of available sites.</p> </li> <li> <code>get_default_neuroglancer_site</code>             \u2013              <p>Get the default neuroglancer site URL.</p> </li> <li> <code>get_neuroglancer_sites</code>             \u2013              <p>Get the list of available neuroglancer sites.</p> </li> <li> <code>neuroglancer_url</code>             \u2013              <p>Check neuroglancer info to determine which kind of site a neuroglancer URL is.</p> </li> <li> <code>set_default_neuroglancer_site</code>             \u2013              <p>Set the default neuroglancer site.</p> </li> </ul>"},{"location":"reference/site_utils/#src.nglui.statebuilder.site_utils.add_neuroglancer_site","title":"<code>add_neuroglancer_site(site_name, site_url, set_default=False)</code>","text":"<p>Add a neuroglancer site to the list of available sites.</p> <p>Parameters:</p> <ul> <li> <code>site_name</code>               (<code>str</code>)           \u2013            <p>Name of the neuroglancer site.</p> </li> <li> <code>site_url</code>               (<code>str</code>)           \u2013            <p>URL of the neuroglancer site.</p> </li> </ul>"},{"location":"reference/site_utils/#src.nglui.statebuilder.site_utils.get_default_neuroglancer_site","title":"<code>get_default_neuroglancer_site()</code>","text":"<p>Get the default neuroglancer site URL.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Single element dictionary with the site and URL of the default neuroglancer site.</p> </li> </ul>"},{"location":"reference/site_utils/#src.nglui.statebuilder.site_utils.get_neuroglancer_sites","title":"<code>get_neuroglancer_sites()</code>","text":"<p>Get the list of available neuroglancer sites.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>List of available neuroglancer URLs and their names.</p> </li> </ul>"},{"location":"reference/site_utils/#src.nglui.statebuilder.site_utils.neuroglancer_url","title":"<code>neuroglancer_url(url=None, target_site=None)</code>","text":"<p>Check neuroglancer info to determine which kind of site a neuroglancer URL is. If either url or target_site are provided, it will use these values, looking up target site from the fallback values in the config. Otherwise, it falls back to the value of \"target_url\" in the config.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>URL to check, by default None</p> </li> <li> <code>target_site</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Target site to check, by default None</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>URL of the neuroglancer viewer</p> </li> </ul>"},{"location":"reference/site_utils/#src.nglui.statebuilder.site_utils.set_default_neuroglancer_site","title":"<code>set_default_neuroglancer_site(site_name)</code>","text":"<p>Set the default neuroglancer site.</p> <p>Parameters:</p> <ul> <li> <code>site_name</code>               (<code>str</code>)           \u2013            <p>Name of the neuroglancer site to set as default.</p> </li> </ul>"},{"location":"reference/skeletons/","title":"statebuilder.skeletons","text":"<p>Classes:</p> <ul> <li> <code>SkeletonManager</code>           \u2013            </li> </ul>"},{"location":"reference/skeletons/#src.nglui.skeletons.skeletons.SkeletonManager","title":"<code>SkeletonManager(segmentation_source, cloudpath, vertex_attributes=None, initialize_info=False, shader=None)</code>","text":"<p>Create a manager to format and upload skeletons to a cloud bucket.</p> <p>Parameters:</p> <ul> <li> <code>segmentation_source</code>               (<code>Union[str, CAVEclient]</code>)           \u2013            <p>The source of the segmentation data, either a string URL or a CAVEclient instance. If a CAVEclient instance is provided, the segmentation_source will be derived from it.</p> </li> <li> <code>cloudpath</code>               (<code>str</code>)           \u2013            <p>The cloudpath where the skeletons will be stored. This is typically a gs:// or s3:// URL.</p> </li> <li> <code>vertex_attributes</code>               (<code>Optional[list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>An ordered list of vertex attribute names to be included in the skeletons, by default None. If None, no vertex attributes will be included.</p> </li> <li> <code>initialize_info</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to initialize the skeleton info in the cloud bucket if it does not exist, by default False. If False, an exception will be raised if the info file does not exist.</p> </li> <li> <code>shader</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>A shader string to be used for rendering the skeletons in Neuroglancer, by default None.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>initialize_skeleton_info</code>             \u2013              <p>Initialize the skeleton info with the vertex attributes.</p> </li> <li> <code>make_shader</code>             \u2013              <p>Create a shader for the skeletons based on the vertex attributes and other parameters.</p> </li> <li> <code>to_segmentation_layer</code>             \u2013              <p>Generate a SegmentationLayer with the segmentation source and skeleton source, as well as uploaded segments and shader specified</p> </li> <li> <code>upload_skeleton</code>             \u2013              <p>Upload a skeleton to the cloud bucket.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>shader</code>               (<code>str</code>)           \u2013            <p>Return a skeleton shader with appropriate vertex properties and other attributes as set in <code>make_shader</code>.</p> </li> <li> <code>skeleton_source</code>               (<code>str</code>)           \u2013            <p>Get the skeleton source URL for neuroglancer.</p> </li> <li> <code>uploaded_root_ids</code>               (<code>list[int]</code>)           \u2013            <p>Get the set of root IDs that have been uploaded since the SkeletonManager was initialized.</p> </li> <li> <code>vertex_attribute_names</code>               (<code>list[str]</code>)           \u2013            <p>The names of the vertex attributes in the skeletons.</p> </li> <li> <code>vertex_attributes</code>               (<code>dict</code>)           \u2013            <p>The neuroglancer-formated vertex attribute dictionary for the skeletons.</p> </li> </ul>"},{"location":"reference/skeletons/#src.nglui.skeletons.skeletons.SkeletonManager.shader","title":"<code>shader</code>  <code>property</code>","text":"<p>Return a skeleton shader with appropriate vertex properties and other attributes as set in <code>make_shader</code>. If no shader is set, return a default shader that uses the vertex attributes defined in the SkeletonManager.</p>"},{"location":"reference/skeletons/#src.nglui.skeletons.skeletons.SkeletonManager.skeleton_source","title":"<code>skeleton_source</code>  <code>property</code>","text":"<p>Get the skeleton source URL for neuroglancer.</p>"},{"location":"reference/skeletons/#src.nglui.skeletons.skeletons.SkeletonManager.uploaded_root_ids","title":"<code>uploaded_root_ids</code>  <code>property</code>","text":"<p>Get the set of root IDs that have been uploaded since the SkeletonManager was initialized.</p>"},{"location":"reference/skeletons/#src.nglui.skeletons.skeletons.SkeletonManager.vertex_attribute_names","title":"<code>vertex_attribute_names</code>  <code>property</code>","text":"<p>The names of the vertex attributes in the skeletons.</p>"},{"location":"reference/skeletons/#src.nglui.skeletons.skeletons.SkeletonManager.vertex_attributes","title":"<code>vertex_attributes</code>  <code>property</code>","text":"<p>The neuroglancer-formated vertex attribute dictionary for the skeletons.</p>"},{"location":"reference/skeletons/#src.nglui.skeletons.skeletons.SkeletonManager.initialize_skeleton_info","title":"<code>initialize_skeleton_info()</code>","text":"<p>Initialize the skeleton info with the vertex attributes.</p>"},{"location":"reference/skeletons/#src.nglui.skeletons.skeletons.SkeletonManager.make_shader","title":"<code>make_shader(checkbox_controls=None, sliders=None, defined_colors=None, body=None)</code>","text":"<p>Create a shader for the skeletons based on the vertex attributes and other parameters. The value will be stored in the shader property of the SkeletonManager instance.</p> <p>Parameters:</p> <ul> <li> <code>checkbox_controls</code>               (<code>Optional[dict]</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary of checkbox controls for the shader, by default None. Keys are the control names and values are booleans indicating whether the control is enabled by default. A pure list can also be provided, in which case all controls will be enabled by default.</p> </li> <li> <code>sliders</code>               (<code>Optional[dict]</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary or list of slider controls for the shader, by default None. Keys are the control names and values are tuples with the type (float or int), min, max, and default value. If provided as al list, all sliders will be set to float type with default range of 0 to 1 and value of 0.5.</p> </li> <li> <code>defined_colors</code>               (<code>Optional[dict]</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary of defined colors for the shader, by default None. Keys are the color variable names and values are tuples with hex or web color names. If provided as a list, sequential colors from the Tableau 10 colormap will be used.</p> </li> <li> <code>body</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Additional body code for the shader, by default None. This can be used to add custom shader logic or functions and should contain the emitRGB function. If None, a default body will be generated.</p> </li> </ul>"},{"location":"reference/skeletons/#src.nglui.skeletons.skeletons.SkeletonManager.to_segmentation_layer","title":"<code>to_segmentation_layer(name='seg', uploaded_segments=True, segments_visible=True, shader=None)</code>","text":"<p>Generate a SegmentationLayer with the segmentation source and skeleton source, as well as uploaded segments and shader specified</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>, default:                   <code>'seg'</code> )           \u2013            <p>The name of the segmentation layer, by default \"seg\".</p> </li> <li> <code>uploaded_segments</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include the uploaded segments in the layer, by default True. If True, the segments will be set to the uploaded root IDs with visibility set to segments_visible.</p> </li> <li> <code>segments_visible</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the uploaded segments should be visible in the layer, by default True.</p> </li> <li> <code>shader</code>               (<code>Optional[Union[bool, str]]</code>, default:                   <code>None</code> )           \u2013            <p>A shader string to be used for the segmentation layer, by default None. If False, no shader will be applied. If None, the shader from the SkeletonManager will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationLayer</code>           \u2013            <p>A SegmentationLayer object with the specified parameters. This can be used in a ViewerState.add_layer method.</p> </li> </ul>"},{"location":"reference/skeletons/#src.nglui.skeletons.skeletons.SkeletonManager.upload_skeleton","title":"<code>upload_skeleton(root_id, vertices, edges=None, vertex_attribute_data=None)</code>","text":"<p>Upload a skeleton to the cloud bucket. Note that uploading the skeleton will add the root ID to the set of uploaded root IDs property.</p> <p>Parameters:</p> <ul> <li> <code>root_id</code>               (<code>int</code>)           \u2013            <p>The root ID of the skeleton.</p> </li> <li> <code>vertices</code>               (<code>ndarray</code>)           \u2013            <p>The vertices of the skeleton as a numpy array of shape (N, 3).</p> </li> <li> <code>edges</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>The edges of the skeleton as a numpy array of shape (M, 2), by default None. If None, an empty edge list will be created and the \"skeleton\" will be treated as a set of disconnected vertices.</p> </li> <li> <code>vertex_attribute_data</code>               (<code>Optional[Union[dict, DataFrame]]</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary or DataFrame containing vertex attribute data, where keys are attribute names and values are arrays of the same length as vertices. If any of the vertex attributes are not provided, they will default to zero arrays of the same length as vertices.</p> </li> </ul>"},{"location":"reference/statebuilder/","title":"statebuilder.base","text":"<p>Classes:</p> <ul> <li> <code>ViewerState</code>           \u2013            </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState","title":"<code>ViewerState(target_site=None, target_url=None, layers=None, dimensions=None, *, position=None, scale_imagery=1.0, scale_3d=50000.0, show_slices=False, selected_layer=None, selected_layer_visible=False, layout='xy-3d', base_state=None, interactive=False, infer_coordinates=True, client=None)</code>","text":"<p>Parameters:</p> <ul> <li> <code>target_site</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The target site for the viewer. If None, the default site will be used.</p> </li> <li> <code>target_url</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The target URL for the viewer. If None, the default URL will be used.</p> </li> <li> <code>layers</code>               (<code>list of Layer</code>, default:                   <code>None</code> )           \u2013            <p>The layers to add to the viewer.</p> </li> <li> <code>dimensions</code>               (<code>list or CoordSpace</code>, default:                   <code>None</code> )           \u2013            <p>The dimensions of the viewer. If None, the default dimensions will be used.</p> </li> <li> <code>position</code>               (<code>list or ndarray</code>, default:                   <code>None</code> )           \u2013            <p>The position of the viewer in 3D space. If None, the default position will be used.</p> </li> <li> <code>scale_imagery</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The scale factor for imagery layers. Default is 1.0.</p> </li> <li> <code>scale_3d</code>               (<code>float</code>, default:                   <code>50000.0</code> )           \u2013            <p>The scale factor for 3D projections. Default is 50000.0.</p> </li> <li> <code>show_slices</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to show cross-sectional slices in the viewer. Default is False.</p> </li> <li> <code>selected_layer</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the selected layer. If None, no layer is selected.</p> </li> <li> <code>selected_layer_visible</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the selected layer is visible. Default is False.</p> </li> <li> <code>layout</code>               (<code>str</code>, default:                   <code>'xy-3d'</code> )           \u2013            <p>The panel layout of the viewer. Default is \"xy-3d\".</p> </li> <li> <code>base_state</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>The base state of the viewer. If None, the default state will be used.</p> </li> <li> <code>interactive</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the viewer is interactive. Default is False.</p> </li> <li> <code>infer_coordinates</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to infer resolution and position from the source information using CloudVolume. Default is True.</p> </li> <li> <code>client</code>               (<code>CAVEclient</code>, default:                   <code>None</code> )           \u2013            <p>A CAVE client to use for configuration. If provided, it will be used by default in functions that can accept it.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>add_annotation_layer</code>             \u2013              <p>Add an annotation layer, either local or with precomputed annotation source</p> </li> <li> <code>add_annotation_source</code>             \u2013              <p>Add a precomputed annotation source to the viewer.</p> </li> <li> <code>add_boxes</code>             \u2013              <p>Add bounding box annotations to an existing annotation layer or create a new one.</p> </li> <li> <code>add_ellipsoids</code>             \u2013              <p>Add ellipsoid annotations to an existing annotation layer or create a new one.</p> </li> <li> <code>add_image_layer</code>             \u2013              <p>Add an image layer to the viewer.</p> </li> <li> <code>add_layer</code>             \u2013              <p>Add a layer to the viewer.</p> </li> <li> <code>add_layers_from_client</code>             \u2013              <p>Configure the viewer with information from a CaveClient.</p> </li> <li> <code>add_lines</code>             \u2013              <p>Add lines to an existing annotation layer or create a new one.</p> </li> <li> <code>add_points</code>             \u2013              <p>Add points to an existing annotation layer or create a new one.</p> </li> <li> <code>add_raw_layer</code>             \u2013              <p>Add a layer based on a raw state dictionary. Useful when copying existing layers, but offers limited customization.</p> </li> <li> <code>add_segment_properties</code>             \u2013              <p>Upload segment properties and add to the layer.</p> </li> <li> <code>add_segmentation_layer</code>             \u2013              <p>Add a segmentation layer to the viewer.</p> </li> <li> <code>add_segments</code>             \u2013              <p>Add segments directly to an existing segmentation layer.</p> </li> <li> <code>add_segments_from_data</code>             \u2013              <p>Add segments from a DataFrame or DataMap to an existing segmentation layer.</p> </li> <li> <code>get_layer</code>             \u2013              <p>Get a layer by name.</p> </li> <li> <code>map</code>             \u2013              <p>Apply a datamap to the viewer state to freeze the state of the viewer.</p> </li> <li> <code>set_viewer_properties</code>             \u2013              <p>Set various properties of the viewer state.</p> </li> <li> <code>to_browser</code>             \u2013              <p>Open the viewer state URL in a web browser.</p> </li> <li> <code>to_clipboard</code>             \u2013              <p>Copy the viewer state URL to the system clipboard.</p> </li> <li> <code>to_dict</code>             \u2013              <p>Return a dictionary representation of the viewer state.</p> </li> <li> <code>to_json_string</code>             \u2013              <p>Return a JSON string representation of the viewer state.</p> </li> <li> <code>to_link</code>             \u2013              <p>Return an HTML link representation of the viewer state.</p> </li> <li> <code>to_link_shortener</code>             \u2013              <p>Shorten the URL using the CAVE link shortener service.</p> </li> <li> <code>to_url</code>             \u2013              <p>Return a URL representation of the viewer state.</p> </li> <li> <code>with_datamap</code>             \u2013              <p>Context manager to apply datamaps.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>viewer</code>           \u2013            <p>Get the Neuroglancer viewer object.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.viewer","title":"<code>viewer</code>  <code>property</code>","text":"<p>Get the Neuroglancer viewer object.</p>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.add_annotation_layer","title":"<code>add_annotation_layer(name='annotation', source=None, resolution=None, tags=None, linked_segmentation=True, shader=None, **kwargs)</code>","text":"<p>Add an annotation layer, either local or with precomputed annotation source</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>, default:                   <code>'annotation'</code> )           \u2013            <p>Layer name, by default \"annotation\"</p> </li> <li> <code>source</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Cloud annotation source path, if using. By default None</p> </li> <li> <code>resolution</code>               (<code>Optional[Union[list, ndarray]]</code>, default:                   <code>None</code> )           \u2013            <p>Layer resolution, only used by local annotation layers. By default None, where it is inferred from the viewer.</p> </li> <li> <code>tags</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>Ordered list of tags, by default None.</p> </li> <li> <code>linked_segmentation</code>               (<code>Union[str, bool]</code>, default:                   <code>True</code> )           \u2013            <p>If True, will link to the first segmentation layer found in the viewer. If False, will not link to any segmentation layer. If a string is provided, it will be used as the name of the segmentation layer to link to.</p> </li> <li> <code>**kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the annotation layer constructor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The viewer state object with the added annotation layer.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.add_annotation_source","title":"<code>add_annotation_source(source, name='annotation', linked_segmentation=True, shader=None)</code>","text":"<p>Add a precomputed annotation source to the viewer.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>str</code>)           \u2013            <p>The source path for the annotation layer.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>'annotation'</code> )           \u2013            <p>The name of the annotation layer, by default \"annotation\".</p> </li> <li> <code>shader</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The shader to use for the annotation layer, by default None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The viewer state object with the added annotation layer.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.add_boxes","title":"<code>add_boxes(data=None, name='annotation', point_a_column=None, point_b_column=None, segment_column=None, description_column=None, tag_column=None, tag_bools=None, data_resolution=None, tags=None, linked_segmentation=True, shader=None, color=None, swap_visible_segments_on_move=True)</code>","text":"<p>Add bounding box annotations to an existing annotation layer or create a new one.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>, default:                   <code>None</code> )           \u2013            <p>The DataFrame containing the bounding box annotations.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>'annotation'</code> )           \u2013            <p>The name of the annotation layer, by default \"annotation\".</p> </li> <li> <code>point_a_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the start point coordinates of the box.</p> </li> <li> <code>point_b_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the end point coordinates of the box.</p> </li> <li> <code>segment_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the column containing linked segment IDs, by default None.</p> </li> <li> <code>description_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the column containing descriptions, by default None.</p> </li> <li> <code>tag_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of a column containing tags, by default None.</p> </li> <li> <code>tag_bools</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>A list of column names indicating tags as booleans, by default None.</p> </li> <li> <code>data_resolution</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the data, by default None.</p> </li> <li> <code>tags</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>A list of tags to add to the annotation layer, by default None.</p> </li> <li> <code>linked_segmentation</code>               (<code>str or bool</code>, default:                   <code>True</code> )           \u2013            <p>The name of the segmentation layer to link to, by default None. If True, will link to the first segmentation layer found in the viewer. If False, will not link to any segmentation layer.</p> </li> <li> <code>shader</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The shader to use for the annotation layer, by default None.</p> </li> <li> <code>color</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The color to use for the bounding boxes, by default None.</p> </li> <li> <code>swap_visible_segments_on_move</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, will swap the visibility of segments when moving boxes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The viewer state object with the added bounding boxes.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.add_ellipsoids","title":"<code>add_ellipsoids(data=None, name='annotation', center_column=None, radii_column=None, segment_column=None, description_column=None, tag_column=None, tag_bools=None, data_resolution=None, tags=None, linked_segmentation=True, shader=None, color=None, swap_visible_segments_on_move=True)</code>","text":"<p>Add ellipsoid annotations to an existing annotation layer or create a new one.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>, default:                   <code>None</code> )           \u2013            <p>The DataFrame containing the ellipsoid annotations.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>'annotation'</code> )           \u2013            <p>The name of the annotation layer, by default \"annotation\".</p> </li> <li> <code>center_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the ellipsoid center coordinates.</p> </li> <li> <code>radii_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the ellipsoid radii.</p> </li> <li> <code>segment_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the column containing linked segment IDs, by default None.</p> </li> <li> <code>description_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the column containing descriptions, by default None.</p> </li> <li> <code>tag_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of a column containing tags, by default None.</p> </li> <li> <code>tag_bools</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>A list of column names indicating tags as booleans, by default None.</p> </li> <li> <code>data_resolution</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the data, by default None.</p> </li> <li> <code>tags</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>A list of tags to add to the annotation layer, by default None.</p> </li> <li> <code>linked_segmentation</code>               (<code>str or bool</code>, default:                   <code>True</code> )           \u2013            <p>The name of the segmentation layer to link to, by default None. If True, will link to the first segmentation layer found in the viewer. If False, will not link to any segmentation layer.</p> </li> <li> <code>shader</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The shader to use for the annotation layer, by default None.</p> </li> <li> <code>color</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The color to use for the ellipsoids, by default None.</p> </li> <li> <code>swap_visible_segments_on_move</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, will swap the visibility of segments when moving ellipsoids.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The viewer state object with the added ellipsoids.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.add_image_layer","title":"<code>add_image_layer(source, name='imagery', resolution=None, **kwargs)</code>","text":"<p>Add an image layer to the viewer.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>str</code>)           \u2013            <p>The source path for the image layer.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>'imagery'</code> )           \u2013            <p>The name of the image layer, by default \"imagery\".</p> </li> <li> <code>resolution</code>               (<code>Optional[Union[list, ndarray]]</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the image layer. If None, the viewer's current resolution will be used or it will be inferred from the source (if cloud-volume is installed).</p> </li> <li> <code>**kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the image layer constructor.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.add_layer","title":"<code>add_layer(layers, selected=False)</code>","text":"<p>Add a layer to the viewer.</p> <p>Parameters:</p> <ul> <li> <code>layers</code>               (<code>Layer or list of Layer</code>)           \u2013            <p>The layer(s) to add to the viewer.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.add_layers_from_client","title":"<code>add_layers_from_client(client=None, imagery=True, segmentation=True, skeleton_source=True, resolution=True, target_url=False, selected_alpha=None, alpha_3d=None, mesh_silhouette=None, imagery_kws=None, segmentation_kws=None)</code>","text":"<p>Configure the viewer with information from a CaveClient. Can set the target URL, viewer resolution, and add image and segmentation layers.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>CAVEclient</code>, default:                   <code>None</code> )           \u2013            <p>The client to use for configuration. If None, will use the client set in the viewer state if allowed.</p> </li> <li> <code>imagery</code>               (<code>Union[bool, str]</code>, default:                   <code>True</code> )           \u2013            <p>Whether to add an image layer, by default True. If a string is provided, it will be used as the name of the layer.</p> </li> <li> <code>segmentation</code>               (<code>Union[bool, str]</code>, default:                   <code>True</code> )           \u2013            <p>Whether to add a segmentation layer, by default True If a string is provided, it will be used as the name of the layer.</p> </li> <li> <code>skeleton_source</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to try to add a skeleton source for the segmentation layer, if provided, by default True</p> </li> <li> <code>resolution</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to infer viewer resolution from the client info, by default True</p> </li> <li> <code>target_url</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to set the neuroglancer URL from the client, by default False</p> </li> <li> <code>selected_alpha</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>The alpha value for the segmentation layer, by default None.</p> </li> <li> <code>alpha_3d</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>The alpha value for 3D meshes, by default None.</p> </li> <li> <code>mesh_silhouette</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>The mesh silhouette value, by default None.</p> </li> <li> <code>imagery_kws</code>               (<code>Optional[dict]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the image layer constructor.</p> </li> <li> <code>segmentation_kws</code>               (<code>Optional[dict]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the segmentation layer constructor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The updated viewer state object.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.add_lines","title":"<code>add_lines(data=None, name='annotation', point_a_column=None, point_b_column=None, segment_column=None, description_column=None, tag_column=None, tag_bools=None, data_resolution=None, tags=None, linked_segmentation=True, shader=None, color=None, swap_visible_segments_on_move=True)</code>","text":"<p>Add lines to an existing annotation layer or create a new one.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>, default:                   <code>None</code> )           \u2013            <p>The DataFrame containing the line annotations or a tuple of (start_points, end_points) as Nx3 arrays.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>'annotation'</code> )           \u2013            <p>The name of the annotation layer, by default \"annotation\".</p> </li> <li> <code>point_a_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the start point coordinates. If you have a split point representation in the format {prefix}_x, {prefix}_y, {prefix}_z, you can specify this with \"prefix\" only and the suffixes will be ignored. If you provide a list, they will be used explicitly as the x,y, and z columns.</p> </li> <li> <code>point_b_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the end point coordinates, formatted similarly as <code>point_a_column</code>.</p> </li> <li> <code>segment_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the column containing linked segment IDs, by default None.</p> </li> <li> <code>description_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the column containing descriptions, by default None.</p> </li> <li> <code>tag_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of a column containing tags, by default None.</p> </li> <li> <code>tag_bools</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>A list of column names indicating tags as booleans, by default None.</p> </li> <li> <code>data_resolution</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the data, by default None.</p> </li> <li> <code>tags</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>A list of tags to add to the annotation layer, by default None.</p> </li> <li> <code>linked_segmentation</code>               (<code>str or bool</code>, default:                   <code>True</code> )           \u2013            <p>The name of the segmentation layer to link to, by default None. If True, will link to the first segmentation layer found in the viewer. If False, will not link to any segmentation layer.</p> </li> <li> <code>shader</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The shader to use for the annotation layer, by default None.</p> </li> <li> <code>color</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The color to use for the lines, by default None.</p> </li> <li> <code>swap_visible_segments_on_move</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, will swap the visibility of segments when moving lines.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The viewer state object with the added lines.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.add_points","title":"<code>add_points(data=None, name='annotation', point_column=None, segment_column=None, description_column=None, tag_column=None, tag_bools=None, data_resolution=None, tags=None, linked_segmentation=True, shader=None, color=None, swap_visible_segments_on_move=True)</code>","text":"<p>Add points to an existing annotation layer or create a new one.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Union[list, ndarray, DataFrame]</code>, default:                   <code>None</code> )           \u2013            <p>The data to add to the annotation layer.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>'annotation'</code> )           \u2013            <p>The name of the annotation layer, by default \"annotation\".</p> </li> <li> <code>point_column</code>               (<code>Optional[Union[str, list]] = None,</code>, default:                   <code>None</code> )           \u2013            <p>The name of the column containing point coordinates, by default None. If you have a split point representation in the format {prefix}_x, {prefix}_y, {prefix}_z, you can specify this with \"prefix\" only and the suffixes will be ignored. If you provide a list, they will be used explicitly as the x,y, and z columns. None is needed if the data is an array, but is required if the data is a DataFrame.</p> </li> <li> <code>segment_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the column containing linked segment IDs, by default None.</p> </li> <li> <code>description_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the column containing descriptions, by default None. If None, no descriptions will be added.</p> </li> <li> <code>tag_column</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of a column containing tags, by default None.</p> </li> <li> <code>tag_bools</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>A list of column names indicating tags as booleans, by default None.</p> </li> <li> <code>data_resolution</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the data, by default None. If None, the viewer's current resolution will be used.</p> </li> <li> <code>tags</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>A list of tags to add to the annotation layer, by default None. If None, tags will be inferred from the data, if any tag columns are provided.</p> </li> <li> <code>linked_segmentation</code>               (<code>str or bool</code>, default:                   <code>True</code> )           \u2013            <p>The name of the segmentation layer to link to, by default None. If True, will link to the first segmentation layer found in the viewer. If False, will not link to any segmentation layer.</p> </li> <li> <code>shader</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The shader to use for the annotation layer, by default None. If None, the default shader will be used.</p> </li> <li> <code>swap_visible_segments_on_move</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, will swap the visibility of segments when moving points.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The viewer state object with the added points.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.add_raw_layer","title":"<code>add_raw_layer(data, name=None, visible=None, archived=None, source_remap=None)</code>","text":"<p>Add a layer based on a raw state dictionary. Useful when copying existing layers, but offers limited customization.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict</code>)           \u2013            <p>The raw state dictionary for the layer.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The new name of the layer, if you want to change it.</p> </li> <li> <code>visible</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether the layer is visible, if you want to change it.</p> </li> <li> <code>archived</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether the layer is archived, if you want to change it.</p> </li> <li> <code>source_remap</code>               (<code>Optional[dict]</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary mapping source cloudpaths to new cloudpaths, for example to update the layer's data source without changing anything else.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The updated viewer state object.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.add_segment_properties","title":"<code>add_segment_properties(data, id_column='pt_root_id', client=None, label_column=None, description_column=None, string_columns=None, number_columns=None, tag_value_columns=None, tag_bool_columns=None, tag_descriptions=None, allow_disambiguation=True, label_separator='_', label_format_map=None, prepend_col_name=False, random_columns=None, random_column_prefix=None, dry_run=False, name=None)</code>","text":"<p>Upload segment properties and add to the layer. If you already have a segment properties cloud path, use <code>add_source</code> to add it to the layer.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>The DataFrame containing the segment properties.</p> </li> <li> <code>id_column</code>               (<code>str</code>, default:                   <code>'pt_root_id'</code> )           \u2013            <p>The column name for the segment IDs. Default is 'pt_root_id'.</p> </li> <li> <code>client</code>               (<code>CAVEclient</code>, default:                   <code>None</code> )           \u2013            <p>The CAVEclient object needed to upload .</p> </li> <li> <code>label_column</code>               (<code>str or list</code>, default:                   <code>None</code> )           \u2013            <p>The column name(s) for the segment labels. Default is None.</p> </li> <li> <code>description_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The column name for the segment descriptions. Default is None.</p> </li> <li> <code>string_columns</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The column names for string properties. Default is None.</p> </li> <li> <code>number_columns</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The column names for number properties. Default is None.</p> </li> <li> <code>tag_value_columns</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The column names for tag value properties. Default is None.</p> </li> <li> <code>tag_bool_columns</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The column names for tag boolean properties. Default is None.</p> </li> <li> <code>tag_descriptions</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>The descriptions for the tags. Default is None.</p> </li> <li> <code>allow_disambiguation</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to allow disambiguation of segment IDs. Default is True.</p> </li> <li> <code>label_separator</code>               (<code>str</code>, default:                   <code>'_'</code> )           \u2013            <p>The separator for label formatting. Default is \"_\".</p> </li> <li> <code>label_format_map</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The format map for labels. Default is None.</p> </li> <li> <code>prepend_col_name</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to prepend the column name to the label. Default is False.</p> </li> <li> <code>random_columns</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Number of random columns to add. Default is None.</p> </li> <li> <code>random_column_prefix</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name prefix of the random columns. Default is None.</p> </li> <li> <code>dry_run</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If dry run is true, build but do not actually upload and instead use a placeholder source text. Default is False.</p> </li> <li> <code>name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Layer name. Must be specified if there is more than one segmentation layer in the state.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.add_segmentation_layer","title":"<code>add_segmentation_layer(source, name='segmentation', resolution=None, segments=None, **kwargs)</code>","text":"<p>Add a segmentation layer to the viewer.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>str</code>)           \u2013            <p>The source path for the segmentation layer.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>'segmentation'</code> )           \u2013            <p>The name of the segmentation layer, by default \"segmentation\".</p> </li> <li> <code>resolution</code>               (<code>Optional[Union[list, ndarray]]</code>, default:                   <code>None</code> )           \u2013            <p>The resolution of the segmentation layer. If None, the viewer's current resolution will be used or it will be inferred from the source (if cloud-volume is installed).</p> </li> <li> <code>segments</code>               (<code>Optional[list]</code>, default:                   <code>None</code> )           \u2013            <p>A list of segments to set as selected in the segmentation layer.</p> </li> <li> <code>**kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the segmentation layer constructor.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.add_segments","title":"<code>add_segments(segments, visible=None, segment_colors=None, name=None)</code>","text":"<p>Add segments directly to an existing segmentation layer. By default, it will use the first segmentation layer found in the viewer, otherwise you must specify a layer name.</p> <p>Parameters:</p> <ul> <li> <code>segments</code>               (<code>list or dict or VisibleSegments</code>)           \u2013            <p>The segments to add. If a dict, the keys are the segment IDs and the values are the boolean visibility.</p> </li> <li> <code>visible</code>               (<code>Optional[Union[list, ndarray]]</code>, default:                   <code>None</code> )           \u2013            <p>The visibility of the segments, assumed to be True if not provided. Should be the same length as segments, and segments should be a list of the same length.</p> </li> <li> <code>segment_colors</code>               (<code>Union[str, list, dict]</code>, default:                   <code>None</code> )           \u2013            <p>The color(s) to assign to the segments. If a string or list, all segments will be assigned the same color. A list is assumed to be a color tuple. If a dict, the keys are segment IDs and the values are colors.</p> </li> <li> <code>name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the segmentation layer to add segments to. If None, it will use the first segmentation layer found in the viewer.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>The viewer state object with the added segments.</code>           \u2013            </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.add_segments_from_data","title":"<code>add_segments_from_data(data, segment_column, visible_column=None, color_column=None, name=None)</code>","text":"<p>Add segments from a DataFrame or DataMap to an existing segmentation layer. By default, it will use the first segmentation layer found in the viewer, otherwise you must specify a layer name.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Union[DataFrame, DataMap]</code>)           \u2013            <p>The data containing segment information or a datamap to be filled in later</p> </li> <li> <code>segment_column</code>               (<code>str</code>)           \u2013            <p>The name of the column containing segment IDs in the DataFrame.</p> </li> <li> <code>visible_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the column containing visibility information in the DataFrame. If not provided, all segments will be considered visible.</p> </li> <li> <code>color_column</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the column containing color information for the segments.</p> </li> <li> <code>name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the segmentation layer to add segments to. If None, it will use the first segmentation layer found in the viewer.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.get_layer","title":"<code>get_layer(name)</code>","text":"<p>Get a layer by name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the layer to get.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Layer</code>           \u2013            <p>The layer with the specified name.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.map","title":"<code>map(datamap, inplace=False)</code>","text":"<p>Apply a datamap to the viewer state to freeze the state of the viewer. Must be used if any layers use a datamap. By default, this will return a new viewer state with the datamap applied without changing the current object.</p> <p>Parameters:</p> <ul> <li> <code>datamap</code>               (<code>dict</code>)           \u2013            <p>A dictionary mapping layer names to their corresponding datamaps.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, apply the datamap in place and return the modified viewer state. If False, return a new viewer state with the datamap applied.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A new ViewerState object with the datamap applied.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.set_viewer_properties","title":"<code>set_viewer_properties(position=None, dimensions=None, scale_imagery=None, scale_3d=None, show_slices=None, selected_layer=None, selected_layer_visible=None, layout=None, base_state=None, interactive=None, infer_coordinates=False)</code>","text":"<p>Set various properties of the viewer state.</p> <p>This function allows you to configure the viewer's position, dimensions, scale, layout, and other properties. Any property not explicitly set will remain unchanged.</p> <p>Parameters:</p> <ul> <li> <code>position</code>               (<code>list or ndarray</code>, default:                   <code>None</code> )           \u2013            <p>The position of the viewer in 3D space.</p> </li> <li> <code>dimensions</code>               (<code>list or ndarray</code>, default:                   <code>None</code> )           \u2013            <p>The dimensions of the viewer's coordinate space. Can be either a list of 3 values treated as nanometer resolution or a CoordSpace object with more detailed options.</p> </li> <li> <code>scale_imagery</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The scale factor for imagery layers.</p> </li> <li> <code>scale_3d</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The scale factor for 3D projections.</p> </li> <li> <code>show_slices</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether to show cross-sectional slices in the viewer.</p> </li> <li> <code>selected_layer</code>               (<code>str or ImageLayer</code>, default:                   <code>None</code> )           \u2013            <p>The name of the selected layer or the layer object itself.</p> </li> <li> <code>selected_layer_visible</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether the selected layer is visible.</p> </li> <li> <code>layout</code>               (<code>('xy', 'yz', 'xz', 'xy-3d', 'xz-3d', 'yz-3d', '4panel', '3d', '4panel-alt')</code>, default:                   <code>\"xy\"</code> )           \u2013            <p>The panel layout of the viewer.</p> </li> <li> <code>base_state</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>The base state of the viewer.</p> </li> <li> <code>interactive</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether the viewer is interactive.</p> </li> <li> <code>infer_coordinates</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to infer resolution and position from the source information. If True, the viewer will attempt to extract this information from the info provided by the source if not provided explicitly.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>self</code>           \u2013            <p>The updated viewer state object.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.to_browser","title":"<code>to_browser(target_url=None, target_site=None, shorten=False, client=None, new=2, autoraise=True, browser=None)</code>","text":"<p>Open the viewer state URL in a web browser.</p> <p>Parameters:</p> <ul> <li> <code>target_url</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The base URL to use for the Neuroglancer state. If not provided, the default server URL will be used.</p> </li> <li> <code>target_site</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The target site for the URL, based on the keys in site_utils.NEUROGLANCER_SITES. If not provided, the default server URL will be used.</p> </li> <li> <code>shorten</code>               (<code>Union[bool, Literal['if_long']]</code>, default:                   <code>False</code> )           \u2013            <p>If True, the URL will be shortened using the CAVE link shortener service. If \"if_long\", the URL will only be shortened if it exceeds a certain length.</p> </li> <li> <code>client</code>               (<code>Optional[CAVEclient]</code>, default:                   <code>None</code> )           \u2013            <p>The CAVE client to use for shortening the URL. If not provided, the URL will not be shortened.</p> </li> <li> <code>new</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>If new is 0, the url is opened in the same browser window if possible. If new is 1, a new browser window is opened if possible. If new is 2, a new browser page (\u201ctab\u201d) is opened if possible. Note that not all browsers support all values of new, and some may ignore this parameter.</p> </li> <li> <code>autoraise</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the browser window will be raised to the front when opened. Note that under many window managers this will occur regardless of the setting of this variable.</p> </li> <li> <code>browser</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the browser to use. If None, the system default browser will be used. Note that the browser name needs to be registered on your system, see webbrowser.register for more details.</p> </li> </ul> See Also <p>webbrowser.open : Opens a URL in the web browser.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The URL representation of the viewer state that has also been opened in the browser.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.to_clipboard","title":"<code>to_clipboard(target_url=None, target_site=None, shorten=False, client=None)</code>","text":"<p>Copy the viewer state URL to the system clipboard.</p> <p>Parameters:</p> <ul> <li> <code>target_url</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The base URL to use for the Neuroglancer state. If not provided, the default server URL will be used.</p> </li> <li> <code>target_site</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The target site for the URL, based on the keys in site_utils.NEUROGLANCER_SITES. If not provided, the default server URL will be used.</p> </li> <li> <code>shorten</code>               (<code>Union[bool, Literal['if_long']]</code>, default:                   <code>False</code> )           \u2013            <p>If True, the URL will be shortened using the CAVE link shortener service. If \"if_long\", the URL will only be shortened if it exceeds a certain length.</p> </li> <li> <code>client</code>               (<code>Optional[CAVEclient]</code>, default:                   <code>None</code> )           \u2013            <p>The CAVE client to use for shortening the URL. If not provided, the URL will not be shortened.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The URL representation of the viewer state that has also been copied to the clipboard.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.to_dict","title":"<code>to_dict()</code>","text":"<p>Return a dictionary representation of the viewer state.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary representation of the viewer state.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.to_json_string","title":"<code>to_json_string(indent=2)</code>","text":"<p>Return a JSON string representation of the viewer state.</p> <p>Parameters:</p> <ul> <li> <code>indent</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>The number of spaces to use for indentation in the JSON string. Default is 2.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A JSON string representation of the viewer state.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.to_link","title":"<code>to_link(target_url=None, target_site=None, link_text='Neuroglancer Link', shorten=False, client=None)</code>","text":"<p>Return an HTML link representation of the viewer state.</p> <p>Parameters:</p> <ul> <li> <code>target_url</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The base URL to use for the Neuroglancer state. If not provided, the default server URL will be used.</p> </li> <li> <code>target_site</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The target site for the URL, based on the keys in site_utils.NEUROGLANCER_SITES. If not provided, the default server URL will be used.</p> </li> <li> <code>link_text</code>               (<code>str</code>, default:                   <code>'Neuroglancer Link'</code> )           \u2013            <p>The text to display for the HTML link.</p> </li> <li> <code>shorten</code>               (<code>Union[bool, Literal['if_long']]</code>, default:                   <code>False</code> )           \u2013            <p>If True, the URL will be shortened using the CAVE link shortener service. If \"if_long\", the URL will only be shortened if it exceeds a certain length.</p> </li> <li> <code>client</code>               (<code>Optional[CAVEclient]</code>, default:                   <code>None</code> )           \u2013            <p>The CAVE client to use for shortening the URL. If not provided, the URL will not be shortened.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HTML</code>           \u2013            <p>An HTML link representation of the viewer state.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.to_link_shortener","title":"<code>to_link_shortener(client=None, target_url=None, target_site=None)</code>","text":"<p>Shorten the URL using the CAVE link shortener service.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>CAVEclient</code>, default:                   <code>None</code> )           \u2013            <p>The CAVE client to use for shortening the URL.</p> </li> <li> <code>target_url</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The base URL to use for the Neuroglancer state. If not provided, the default server URL will be used.</p> </li> <li> <code>target_site</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The target site for the URL, based on the keys in site_utils.NEUROGLANCER_SITES. If not provided, the default server URL will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A shortened URL representation of the viewer state.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.to_url","title":"<code>to_url(target_url=None, target_site=None, shorten=False, client=None)</code>","text":"<p>Return a URL representation of the viewer state.</p> <p>Parameters:</p> <ul> <li> <code>target_url</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The base URL to use for the Neuroglancer state. If not provided, the default server URL will be used.</p> </li> <li> <code>target_site</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The target site for the URL, based on the keys in site_utils.NEUROGLANCER . If not provided, the default server URL will be used.</p> </li> <li> <code>shorten</code>               (<code>Union[bool, Literal['if_long']]</code>, default:                   <code>False</code> )           \u2013            <p>If True, the URL will be shortened using the CAVE link shortener service. If \"if_long\", the URL will only be shortened if it exceeds a certain length.</p> </li> <li> <code>client</code>               (<code>Optional[CAVEclient]</code>, default:                   <code>None</code> )           \u2013            <p>The CAVE client to use for shortening the URL. If not provided, the URL will not be shortened.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A URL representation of the viewer state.</p> </li> </ul>"},{"location":"reference/statebuilder/#src.nglui.statebuilder.base.ViewerState.with_datamap","title":"<code>with_datamap(datamap)</code>","text":"<p>Context manager to apply datamaps.</p>"},{"location":"usage/","title":"Introduction","text":"<p>NGLui is split into three main modules, each with its own purpose:</p> <ul> <li>statebuilder: This module provides a framework for building Neuroglancer states programmatically. It allows you to create and manipulate layers, selections, and annotations in a structured way, making it easier to manage complex Neuroglancer states.</li> <li>segmentprops: This module is designed to generate segment properties for Neuroglancer states, either explicitly or through dataframes. It integrates closely with <code>statebuilder</code>, but creates a distinct file outside of the state that must be hosted online.</li> <li>parser: This module provides tools to easily extract information from Neuroglancer states without needing to parse the JSON manually. It allows you to create dataframes for layers, selections, and annotations.</li> </ul> <p>You can find documentation for each module in the sidebar.</p>"},{"location":"usage/config/","title":"Site Configuration","text":""},{"location":"usage/config/#configuring-neuroglancer-sites","title":"Configuring Neuroglancer Sites","text":"<p>NGLui defaults to using the <code>spelunker</code> deployment of Neuroglancer, which is the most aligned with CAVE priorities. However, most if not all of the features in NGLui are compatibile across any contemporary deployment of Neuroglancer and you can use any deployment URL you would like. To help manage different Neuroglancer URLs, there are a small number of functions to set and get the default configuration for Neuroglancer sites.</p>"},{"location":"usage/config/#target_site","title":"<code>target_site</code>","text":"<p>As a convenience, NGLui keeps a dictionary of Neuroglancer URLs (<code>target_url</code>) with readable names (<code>target_site</code>). You can find the current configuration by running <code>get_neuroglancer_sites()</code>. For example, the default values are:</p> <pre><code>&gt;&gt;&gt; from nglui.statebuilder import *\n&gt;&gt;&gt; get_neuroglancer_sites()\n{'spelunker': 'https://spelunker.cave-explorer.org/',\n 'google': 'https://neuroglancer-demo.appspot.com/'}\n</code></pre> <p>This means that setting <code>target_site='spelunker'</code> in Statebuilder export functions will use the URL <code>https://spelunker.cave-explorer.org/</code> as the default Neuroglancer site, and likewise for <code>google</code>.</p> <p>You can add your own sites to this dictionary by using the <code>add_neuroglancer_site</code> function, which takes a <code>target_site</code> and <code>target_url</code> as arguments. You can further set the new site as the default by setting <code>set_default=True</code>.</p> <pre><code>add_neuroglancer_site(\n    'my_neuroglancer',\n    'https://my-neuroglancer.example.com',\n    set_default=True,\n)\n</code></pre> <p>And you can always see the current default site by running <code>get_default_neuroglancer_site()</code>, which will return the <code>target_site</code> and <code>target_url</code> of the current default site. For example, by default this will show:</p> <pre><code>&gt;&gt;&gt; get_default_neuroglancer_site()\n{'spelunker': 'https://spelunker.cave-explorer.org/'}\n</code></pre>"},{"location":"usage/config/#environment-variables","title":"Environment Variables","text":"<p>If you find yourself always using a different Neuroglancer site, you can set the environment variables <code>NGLUI_TARGET_SITE</code> and <code>NGLUI_TARGET_URL</code> to the shortcut name and URL of your preferred Neuroglancer. This will automatically add these values to the site list and set it the default site when you import NGLui, so you don't have to manually set it every time. Note that both variables must be set.</p>"},{"location":"usage/parser/","title":"Parser","text":"<p>The <code>parser</code> module offers a number of tools to get information about neuroglancer states out of the JSON format that neuroglancer uses. The recommended approach here is to pass a dictionary representation of the JSON object the <code>StateParser</code> class and build various kinds of dataframes from it.</p>"},{"location":"usage/parser/#importing-a-state","title":"Importing a State","text":"<p>We will use the <code>CAVEclient</code> class to get a state JSON based on its ID from the \"share\" button, but you could also use the text you can download from the <code>{}</code> button in the viewer or a JSON file you have saved locally.</p> <pre><code>from caveclient import CAVEclient\nfrom nglui import parser\n\nclient = CAVEclient('minnie65_public')\nstate_json = client.state.get_state_json(6107390807113728)\nstate_parser = parser.StateParser(state_json)\n</code></pre> <p>You can now access different aspects of the state through this <code>state_parser</code> object.</p>"},{"location":"usage/parser/#layer-data","title":"Layer Data","text":"<p>For example, to get a list of all layers and their core info, you can use the <code>layer_dataframe</code> method.</p> <pre><code>state_parser.layer_dataframe()\n</code></pre> <p>will give you a table with a row for each layer and columns for layer name, type, source, and whether the layer is archived (i.e. visible) or not.</p> <p>You can also get a list of all selected segments with the <code>selection_dataframe</code> method.</p> <pre><code>state_parser.selection_dataframe()\n</code></pre>"},{"location":"usage/parser/#annotation-data","title":"Annotation Data","text":"<p>will give you a dataframe where each row is a selected segment, and columns show layer name, segment id, and whether or not the segment is visible.</p> <p>Finally, you can get a list of all annotations with the <code>annotation_dataframe</code> method.</p> <pre><code>state_parser.annotation_dataframe()\n</code></pre> <p>will give you a dataframe where each row is an annotation, and columns show layer name, points locations, annotation type, annotation id, linked segmentations, tags, etc. If you are using tags, the <code>expand_tags=True</code> argument will create a column for every tag and assign a boolean value to the row based on whether the tag is present in the annotation. Another option that is sometimes useful is <code>split_points=True</code>, which will create a separate column for each x, y, or z coordinate in the annotation.</p>"},{"location":"usage/segmentprops/","title":"Segment Properties","text":"<p>Segment properties are a method of organizing information about segment IDs in the current Google/Spelunker version of Neuroglancer. Each segmentation layer can have at most one set of segment properties, expressed as an additional <code>source</code> for the layer. The segment properties themselves are simply a JSON file following a particular specification, that allows you to associate labels, descriptions, tags, and numerical values with each segment ID.</p>"},{"location":"usage/segmentprops/#basics","title":"Basics","text":"<p>Segment properties consist of a list of segment IDs and a collection of properties for each ID in the list. There are four types of properties that can be viewed in Neuroglancer:</p> <ul> <li>Label: A string that names each segment ID. Only one per ID per property list.</li> <li>Description: A longer description of each segment ID. Only one per ID per property list.</li> <li>Tags: A small collection of strings that can be used to filter segments. There can be more than one tag per ID.</li> <li>Number: Numeric properties (e.g. depth, synapse count) for each cell. There can be more than one numeric property provided.</li> </ul> <p>In addition, the specification allows string properties, but these are not currently shown in Neuroglancer.</p> Segment properties help make Neuroglancer more browsable from data"},{"location":"usage/segmentprops/#building-segment-properties","title":"Building segment properties","text":"<p>The easiest way to work with segment properties is to build them from a dataframe. The only absolute requirement is that the dataframe has a column associated with segment IDs. For example, assume we have a pandas dataframe <code>df</code> with columns <code>segment_id</code>, <code>soma_depth</code>, and <code>cell_type</code> with some data in them. We can use the <code>SegmentProperties.from_dataframe</code> method to build a <code>SegmentProperties</code> object from this dataframe. In this case, we want <code>soma_depth</code> to be a numeric property and the values  <code>cell_type</code> to be a tag.</p> <pre><code>import pandas as pd\nfrom nglui.segmentprops import SegmentProperties\n\ndf = pd.DataFrame(\n    {'segment_id': [1, 2, 3],\n     'soma_depth': [100, 200, 300],\n     'cell_type': ['pyramidal_cell', 'interneuron', 'interneuron']}\n)\n\nseg_prop = SegmentProperties.from_dataframe(\n    df,\n    id_col='segment_id',\n    number_cols='soma_depth',\n    tag_value_cols='cell_type'\n)\n</code></pre> <p>To get a formatted segment proerties, you can use the <code>to_dict</code> method:</p> <pre><code>seg_prop.to_dict()\n</code></pre> <p>which will produce something like:</p> <pre><code>{'@type': 'neuroglancer_segment_properties',\n 'inline': {'ids': ['1', '2', '3'],\n  'properties': [{'id': 'tags',\n    'type': 'tags',\n    'tags': ['interneuron', 'pyramidal_cell'],\n    'values': [[1], [0], [0]]},\n   {'id': 'soma_depth',\n    'type': 'number',\n    'values': [100, 200, 300],\n    'data_type': 'int32'}]}}\n</code></pre> <p>Note that multiple numeric properties can be passed a list of column names.</p>"},{"location":"usage/segmentprops/#tag-properties","title":"Tag properties","text":"<p>There are two ways to associate tags with segment IDs. When using the <code>tag_value_cols</code> argument, the unique values (except <code>None</code>) across all specified columns are used as tags. Values that are duplicated across different columns will be counted as a single tag. For tag value columns, the order is determined by the sorting of values. By default, this is alphabetical, but it will follow the order from categorical data in pandas.</p> <p>If you need more fine control over the tags, you can use the <code>tag_bool_cols</code> argument. Here, a column name or list of column names are passed with the expectation that each column name represents a tag and if the value of a given row is <code>True</code>, the tag is associated with the segment ID. Here, the order will follow the order of the list.</p> <p>Both <code>tag_value_cols</code> and <code>tag_bool_cols</code> can be used together, with the order being values followed by boolean columns.</p> <p>You can also specify <code>tag_descriptions</code>, a dictionary where the tag names are the keys and longer-form descriptions are the values. Any tag without a description will be passed through directly.</p>"},{"location":"usage/segmentprops/#number-properties","title":"Number properties","text":"<p>If you look at the JSON output above, you see that the <code>soma_depth</code> property has a field \"data_type\" that specifies the type of the numerical property, in this case <code>int32</code>. Data type values are inferred from the column dtype and safe conversions are validated.</p>"},{"location":"usage/segmentprops/#random-number-columns","title":"Random number columns","text":"<p>Often, segment properties are used for very large lists of root ids. If you want to sample just a few percent of these in Neuroglancer, it can be hard to get a small number of random ids without a lot of clicking. Adding a numerical property that is just a random number between 0 and 1 will give you a way to load small subsets of the data using the filter tools. You can add random columns when building a SegmentProperty object from a dataframe by setting the <code>random_columns</code> argument with the number of extra columns you want to add. For example, to add a single random column:</p> <pre><code>seg_prop = SegmentProperties.from_dataframe(\n    df,\n    id_col='segment_id',\n    number_cols='soma_depth',\n    random_columns=1,\n)\n</code></pre> <p>Will add one random column as a numerical property with the default name <code>random_sample</code>. Using numbers higher than 1 will add multiple random columns with names <code>random_sample_0</code>, <code>random_sample_1</code>, etc. The name of the random column can be changed with the <code>random_column_prefix</code> argument. Note that a value error will be raised if you try to add a random column with a name that already exists in the dataframe.</p>"},{"location":"usage/segmentprops/#building-segment-properties-manually","title":"Building segment properties manually","text":"<p>It is also possible to build segment properties manually with the <code>SegmentProperties</code> class. Each type of property is represented by a different class: <code>LabelProperty</code>, <code>DescriptionProperty</code>, <code>TagProperty</code>, and <code>NumberProperty</code>. Each property type has required and optional arguments that are used to build the property. More details can be found in the API reference. You can then either build a SegmentProperties object from these properties, for example:</p> <pre><code>from nglui.segmentprops import SegmentProperties, LabelProperty, NumberProperty\n\nlabels = LabelProperty(values=['cell_1', 'cell_2', 'cell_3'])\nnumbers = NumberProperty(\n    id='hugeness',\n    values=[1,2,3],\n    data_type='float32',\n)\nprops = SegmentProperties(\n    ids = [1,2,3],\n    label_property=labels,\n    number_properties=numbers, # Could be a list of NumberProperty objects as well.\n)\n</code></pre> <p>Note that validation happens on the <code>to_dict</code> method, so you can build invalid properties (such as different-length lists of ids and property values) without error.</p>"},{"location":"usage/segmentprops/#saving-segment-properties","title":"Saving segment properties","text":"<p>Segment properties must be hosted on a server to be used in Neuroglancer. There are two main approaches to this:</p>"},{"location":"usage/segmentprops/#1-use-a-cave-state-server-endpoint-to-upload-properties","title":"1. Use a CAVE state server endpoint to upload properties.","text":"<p>The CAVE state server has a special endpoint you can use to upload segment properties. After initializing a <code>CAVEclient</code> object, you first upload the properties with the <code>upload_property_json</code> method and then build a link from the resulting id you get back.</p> <pre><code>from caveclient import CAVEclient\nclient = CAVEclient('MY_DATASTACK')\nngl_url = \"https://neuroglancer-demo.appspot.com\"\n\nprop_id = client.state.upload_property_json(seg_prop.to_dict())\nprop_url = client.state.build_neuroglancer_url(prop_id, ngl_url=ngl_url, format_properties=True)\n</code></pre> <p>You will then use the resulting URL in the <code>source</code> field of a segmentation layer in Neuroglancer.</p> <p>This approach is convenient, but there is a limit to how large the properties list can be. In addition, you do not get to choose a readable URL for the properties and they must be behind CAVE authentication.</p>"},{"location":"usage/segmentprops/#2-save-the-properties-to-a-file-web-accessible-location","title":"2. Save the properties to a file web-accessible location.","text":"<p>For large properties or properties you want to be publicly accessible, you can save the properties to a file and host them on a web-accessible location with a particular organization.</p> <p>First, save the properties to a file called <code>info</code> (no extensions!)</p> <pre><code>import json\n\nwith open('info', 'w') as f:\n    json.dump(props.to_dict(), f) \n</code></pre> <p>Next, create a directory in a web-accessible location (e.g. <code>https://my-server/my-property</code>) or public cloud bucket (e.g. <code>gs://my-bucket/my-property</code>) and upload the <code>info</code> file to that directory.</p> <p>The URL you will use to load the properties into Neuroglancer will be <code>precomputed://</code> followed by the URL of the directory or bucket (e.g. <code>precomputed://https://my-server/my-property</code> or <code>precomputed://gs://my-bucket/my-property</code>).</p>"},{"location":"usage/segmentprops/#adding-segment-properties-to-neuroglancer","title":"Adding segment properties to Neuroglancer","text":"<p>If saved segment properties with either of the two methods above, you will get a URL that you can load into Neuroglancer as a source for a segmentation layer. If you want to do this manually in a browser you have already have open, select the segmentation layer, go to the source tab, and click the <code>+</code> button to add a new source and paste the URL in.</p>"},{"location":"usage/segmentprops/#segment-properties-in-statebuilder","title":"Segment properties in StateBuilder.","text":"<p>The <code>StateBuilder</code> class lets you set either static segment properties or segment properties that are generated from a dataframe. See the StateBuilder documentation for more details.</p>"},{"location":"usage/skeletons/","title":"Skeletons","text":"<p>Neuroglancer treats skeletons as a collection of vertices and edges and an arbitrary collection of properties that can be mapped to the scene vizualization using GL shaders. Because of that, skeletons \u2014 which can even just be point clouds! \u2014 offer a way to visualize complex neuronal structures in an interactive mannger.</p> <p>However, to use your own skeletons in Neuroglancer you need to create a readable cloud storage bucket with an appropriate structure and info file to host skeletons. The new <code>nglui.skeletons</code> module helps ease this process.</p> <p>Cloud-volume required!</p> <p>The <code>nglui.skeletons</code> module requires the <code>cloud-volume</code> package to be installed. You can install it with <code>pip install cloud-volume</code> or <code>pip install nglui[full]</code>.</p>"},{"location":"usage/skeletons/#creating-a-skeletonmanager","title":"Creating a SkeletonManager","text":"<p>The <code>SkeletonManager</code> class is the main entry point for working with skeletons in NGLui. In order to make a new skeleton bucket, you need to know the following information:</p> <pre><code>- 'segmentation_source`: This is an existing segmentation source whose ids are associated with the skeletons you want to make. This can also be a caveclient, in which case the segmentation source is used.\n- `cloudpath`: This is the cloud storage bucket where the skeletons will be stored. It must be a path that you have access to and have configured `cloud-volume` to write to. Please see the [cloud-volume documentation](https://github.com/seung-lab/cloud-volume?tab=readme-ov-file#credentials) on setting up credentials for more information.\n- `vertex_attributes`: This is a list of attribute names that store properties for skeleton vertices. Because these must be specified in the info file for all skeletons, they must be set ahead of time.\n</code></pre> <p>From there, you can upload skeletons to the bucket using the <code>SkeletonManager</code> methods, which will automatically create the appropriate structure and info file for you. If you already have an existing skeleton bucket, you can provide just a <code>segmentation_source</code> and <code>cloudpath</code> and the <code>SkeletonManager</code> will read the info file and use it to manage skeletons in that bucket. The attributes will be automatically loaded from the info file, so you do not need to specify them again.</p> <p>For example, let's build a skeleton manager that uses the <code>caveclient</code> as the segmentation source, stores skeletons in a Google Cloud Storage bucket, and has a vertex attribute called <code>radius</code>. Assume we have a skeleton <code>sk</code> with segment id <code>12345</code> and a structure represented with a dictionary with <code>'vertices'</code> as a numpy array of shape <code>(n, 3)</code>, <code>edges</code> as a numpy array of shape <code>(n,2)</code> and <code>'radius'</code> as a numpy array of shape <code>(n,)</code>:</p> <pre><code>from nglui import skeletons\n\nskm = skeletons.SkeletonManager(\n    segmentation_source=client,\n    cloudpath=\"gs://my-bucket/ngl-skeletons\",\n    vertex_attributes=['radius'],\n    initialize_info=True,\n)\n\nskm.upload_skeleton(\n    root_id=12345),\n    vertices=sk['vertices'],\n    edges=sk['edges'],\n    vertex_attributes={'radius': sk['radius']},\n)\n</code></pre> <p>This will create the appropriate structure in the bucket, including an <code>info</code> file that describes the skeletons and their attributes, and then upload this skeleton. You will be able to see the skeleton in Neuroglance if this location is added as a source for a segmentation layer. The source path needed for Neuroglancer can be found at the <code>skm.skeleton_source</code> property, which will be something like <code>precomputed://gs://my-bucket/ngl-skeletons</code>.</p> <p>You can also make a segmentation layer directly using the <code>to_segmentation_layer</code> method, which will return a <code>SegmentationLayer</code> object that you can use in a Neuroglancer state. In addition, it will automatically select the segment ids you have uploaded in this session for quick visulization.</p> <p>For example, to visualize the skeletons we just uploaded in a complete Neuroglancer state, we could just do:</p> <pre><code>(\n    ViewerState()\n    .add_image_layer(client.info.image_source())\n    .add_layer(skm.to_segmentation_layer())\n).to_link()\n</code></pre>"},{"location":"usage/statebuilder/","title":"StateBuilder","text":"<p>Statebuilder is a submodule that to produce Neuroglancer links and the JSON states that define them. It is built on top of neuroglancer-python, and helps simplify producing more complex and data-driven states, while automating much of the boilerplate code and integrating with CAVEclient for CAVE-backed datasets.</p>"},{"location":"usage/statebuilder/#neuroglancer-key-concepts","title":"Neuroglancer Key Concepts","text":"<p>To understand how to use StateBuilder, it's helpful to understand the basic Neuroglancer concepts of layers, states, and annotations.</p> <p>Neuroglancer is a web-based viewer for large 3d datasets. Notably, Neuroglancer is designed to be a bit of complex Javascript that runs in your web browser and, generally, looks for data in various cloud-hosted locations. There are a number of different deployments of Neuroglancer, which can be based on slightly different versions of the code or slightly different configurations available. The two deployments that are built into NGLui right now are \"Mainline\" or the default deployment built from the main branch of Neuroglancer from Google and the Spelunker deployment based a bleeding-edge branch focused on CAVE-related features. Additional Neuroglancer deployments can be added using <code>site_utils</code>.</p> <p>Virtually every aspect of Neuroglancer is defined by this state, which is represented by a collection of keys and values in a JSON object that you can see if you click the <code>{}</code> button in the upper left of the Neuroglancer interface. Everything from selecting new objects or adding annotations to zooming or rotating your view is defined in this state, which can be imported or exported effectively as a readable <code>json</code> file. The complete description of the state is typically encoded in the URL, which is how you can easily share most Neuroglancer URLs. Building your own Neuroglancer view is thus simply the process of defining the state and passing it to a Neuroglancer viewer.</p> <p>The state has two main aspects, viewer options that define global properties like the position, the layout of views, and what tabs are open, and layers that define different datas sources and how they are visualized. Layers can be different types with different behaviors: Image layers show 3d imagery, Segmentation layers have \"segments\" with unique ids that can be selected and visualized in 3d with meshes or skeletons, and Annotation layers can show points, lines, or other objects associated with data. Each layer has a name, a source (typically a path to a cloud-hosted dataset), and various configuration options. Layers can actually have multiple complementary data sources of the same type, for example a Segmentation layer can have one source for segmentations and meshes while another source provides skeletons or segment property data. Unlike Image or Segmentation layers, Annotation layers can also have a \"local\" source, where the annotations are directly defined in the Neuroglancer state.</p> <p>The Statebuilder module follows this viewer-and-layer pattern, where you define a viewer with a set of options and then add layers of different types to it. Where possible, Statebuilder tries to tie components together as simply as possible and with reasonble defaults in order to make a Neuroglancer state with as little code as possible.</p> <p>Note</p> <p>Current functionality is focused on viewing data. The many options for controlling the Neuroglancer interface are not yet implemented directly, although they are available in the underlying <code>neuroglancer</code> python library and JSON state. You can always access the raw neuroglancer state with <code>vs.to_neuroglancer_state</code> for further manipulation.</p>"},{"location":"usage/statebuilder/#nglui-viewerstate","title":"NGLui ViewerState","text":"<p>The central object in StateBuilder is the <code>ViewerState</code>, which is used to initialize a Neuroglancer state, set the viewer options, add layers, and finally return the state in various formats. A minimal state joins together a ViewerState with layers. In general, all functions to add data to a state or layer start with add_, functions to set options or parameters start with set_, and functions to export the data to another form (e.g. a URL) start with to_.</p> <p>For example, to add a single image layer using the Microns dataset:</p> <pre><code>from nglui.statebuilder import ViewerState, ImageLayer, SegmentationLayer\n\nviewerstate = ViewerState()\nviewerstate.add_layer(ImageLayer(source='precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie35/em'))\nviewerstate.add_layer(SegmentationLayer(source='precomputed://gs://iarpa_microns/minnie/minnie35/seg_m1300'))\n</code></pre> <p>You can see the layers in the state with in the <code>viewerstate.layers</code> attribute.</p> <pre><code>&gt;&gt;&gt; viewerstate.layers\n[ImageLayer(name='img', source='precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie35/em'),\n SegmentationLayer(name='seg', source='precomputed://gs://iarpa_microns/minnie/minnie35/seg')]\n</code></pre> <p>And then you can turn these options into a Neuroglancer state with functions like <code>to_link</code>:</p> <pre><code>&gt;&gt;&gt; viewerstate.to_link()\n</code></pre> <p>Which returns a Neuroglancer Link with the configuration requested.</p> <p>Danger</p> <p>It is highly recommended to install <code>cloud-volume</code> (which comes with <code>pip install nglui[full]</code>) in order to infer information like the resolution and size of datasets. If you do not want or have <code>cloud-volume</code> installed, you should always set the <code>dimensions</code> property when making a ViewerState (e.g. <code>ViewerState(dimensions=[4,4,40])</code>) to set the voxel resolution in nm/voxel. You can turn off automated resolution suggestions by setting <code>infer_dimensions=False</code> in the ViewerState constructor or explicitly setting the dimensions like above. Note that Neuroglancer does not always behave well if the dimensions are not set ahead of time, for example by setting the initial location or zoom level to be extremely far from the data.</p> <p>Each function like add_layer returns the layer object, so you can also initialize the layers in a pipeline. This pipeline pattern is the one that we will typically use in this documentation.</p> <pre><code>viewerstate = (\n    ViewerState()\n    .add_layer(ImageLayer(source='precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie65/em'))\n    .add_layer(SegmentationLayer(source='precomputed://gs://iarpa_microns/minnie/minnie65/seg_m1300'))\n)\n</code></pre> <p>Or, you could use convenience functions that a ViewerState object has to add layers of different types directly:</p> <pre><code>viewerstate = (\n    ViewerState()\n    .add_image_layer(source='precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie65/em')\n    .add_segmentation_layer(source='precomputed://gs://iarpa_microns/minnie/minnie65/seg_m1300')\n)\n</code></pre> <p>There are many such convenience functions, with the goal of making the most typical use cases as simple as possible while allowing for more complex configurations by using the underlying layer classes directly.</p>"},{"location":"usage/statebuilder/#exporting-states","title":"Exporting States...","text":"<p>You can export the ViewerState to a Neuroglancer state in a number of formats that are useful for different purposes.</p>"},{"location":"usage/statebuilder/#to-urls","title":"...to URLs","text":"<p>The most common way to export a state is to produce a Neuroglancer link or URL, which can be directly opened in a web browser. The basic <code>viewerstate.to_url()</code> function returns the URL as a string formated as a link to a specific Neuroglancer deployment.</p> <pre><code>&gt;&gt;&gt; viewerstate = ViewerState().add_image_layer('precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie65/em')\n&gt;&gt;&gt; viewerstate.to_url()\n'https://spelunker.cave-explorer.org/#!%7B%22position%22:%5B120320.0,103936.0,21360.0%5D,%22layout%22:%22xy-3d%22,%22dimensions%22:%7B%22x%22:%5B8e-09,%22m%22%5D,%22y%22:%5B8e-09,%22m%22%5D,%22z%22:%5B4e-08,%22m%22%5D%7D,%22crossSectionScale%22:1.0,%22projectionScale%22:50000.0,%22showSlices%22:false,%22layers%22:%5B%7B%22type%22:%22image%22,%22source%22:%5B%7B%22url%22:%22precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie65/em%22,%22subsources%22:%7B%7D,%22enableDefaultSubsources%22:true%7D%5D,%22shader%22:%22None%22,%22name%22:%22imagery%22%7D%5D%7D'\n</code></pre> <p>In a notebook context, it is often convenient to return the URL as a formatted HTML link (like we used above), which can be done with <code>viewerstate.to_link()</code>.</p> <p>In addition, CAVE offers a link shortener that can be used to store JSON states and return a shortened URL that can be used to access the state. We can use this link shortener directly using to_link_shortener and passing an appropriate CAVEclient client object.</p> <pre><code>from caveclient import CAVEclient\nclient = CAVEclient('minnie65_public')\n\nviewerstate.to_link_shortener(client)\n</code></pre> <p>will upload the state and return a short link with a form like <code>'https://spelunker.cave-explorer.org/#!middleauth+https://global.daf-apis.com/nglstate/api/v1/4690769064493056'</code>.</p> <p>You can also use the link shortener in the to_url and to_link methods by setting the <code>shorten</code> argument to <code>True</code> or <code>if_long</code> and passing a CAVEclient object. The <code>if_long</code> option will only shorten the url if it gets long enough to start breaking the URL length limits of most browsers, approximately 1.75 million characters.</p> <p>There are also convenience functions for copying the URL to the clipboard or opening it in a web browser, both of which have similar paramaters as the <code>to_url</code> method.</p> <p>The to_clipboard method will copy the URL to your system clipboard, after passing through the link shortener:</p> <pre><code>viewerstate.to_clipboard(shorten=True, client=client)\n</code></pre> <p>And the to_browser method will open the URL in your the web browser of your choosing, again after passing through the link shortener:</p> <pre><code>viewerstate.to_browser(shorten=True, client=client, browser='firefox')\n</code></pre> <p>To change the Neuroglancer web deployment used in all of the url and link functions, you can set a different URL in the <code>target_url</code> parameter of the <code>to_url</code> function. For example, to use the default Neuroglancer deployment, you can do:</p> <pre><code>&gt;&gt;&gt; viewerstate.to_url(target_url='https://neuroglancer-demo.appspot.com')\n'https://neuroglancer-demo.appspot.com#!%7B%22position%22:%5B120320.0,103936.0,21360.0%5D,%22layout%22:%22xy-3d%22,%22dimensions%22:%7B%22x%22:%5B8e-09,%22m%22%5D,%22y%22:%5B8e-09,%22m%22%5D,%22z%22:%5B4e-08,%22m%22%5D%7D,%22crossSectionScale%22:1.0,%22projectionScale%22:50000.0,%22showSlices%22:false,%22layers%22:%5B%7B%22type%22:%22image%22,%22source%22:%5B%7B%22url%22:%22precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie65/em%22,%22subsources%22:%7B%7D,%22enableDefaultSubsources%22:true%7D%5D,%22shader%22:%22None%22,%22name%22:%22imagery%22%7D%5D%7D'\n</code></pre> <p>There is also a <code>target_site</code> dictionary that can be used to set shortcuts for different Neuroglancer deployments, which is used by default in the <code>to_url</code> function. For example, you can set the <code>target_site</code> to <code>'spelunker'</code> to use the Spelunker deployment, or <code>'google'</code> to use the default Neuroglancer deployment. Additional deployments can be added to the <code>target_site</code> dictionary using <code>site_utils</code>. For example, if you want to add a new Neuroglancer deployment hosted at <code>'https://neuroglancer.my-deployment.com'</code> with a  <code>target_site</code> shortcut name <code>'my_new_shortcut'</code>, you could do the following:</p> <pre><code>from nglui.statebuilder import site_utils\n\nsite_utils.add_neuroglancer_site(\n    site_name: 'my_new_shortcut',\n    site_url: 'https://neuroglancer.my-deployment.com',\n)\n</code></pre> <p>Note that this configuration is global and will affect all Neuroglancer states generated in the current Python session.</p>"},{"location":"usage/statebuilder/#to-json","title":"...to JSON","text":"<p>The ViewerState can also be exported to a JSON object, which can be used to export to a file or to pass to other functions.</p> <p>The core function is <code>to_dict</code> which returns the state as a dictionary, with contents equivalent to what you see in the Neuroglancer <code>{}</code> tab.</p> <pre><code>&gt;&gt; viewerstate.to_dict()\n{'position': [120320.0, 103936.0, 21360.0],\n 'layout': 'xy-3d',\n 'dimensions': {'x': [np.float64(8e-09), 'm'],\n  'y': [np.float64(8e-09), 'm'],\n  'z': [np.float64(4e-08), 'm']},\n 'crossSectionScale': 1.0,\n 'projectionScale': 50000.0,\n 'showSlices': False,\n 'layers': [{'type': 'image',\n   'source': [{'url': 'precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie65/em',\n     'subsources': {},\n     'enableDefaultSubsources': True}],\n   'shader': 'None',\n   'name': 'imagery'}]}\n</code></pre> <p>A string-formatted JSON state can be generated with <code>to_json_string</code>, which can be directed pasted into the Neuroglancer <code>{}</code> tab. The main difference is that the string version is formatted as a JSON string, with numpy types converted to standard Python types and uses <code>\"</code> characters as required by JSON. Note that it also contains <code>\\n</code> newline characters and (optional) indents and thus is amenable to <code>print</code> or writing to a file.</p>"},{"location":"usage/statebuilder/#to-neuroglancer-python","title":"...to Neuroglancer python","text":"<p>The ViewerState object can also be converted to a <code>neuroglancer.Viewer</code> object, which is the underlying object used by the Neuroglancer python library. This can be done with the <code>to_neuroglancer_state</code> function, which returns a <code>neuroglancer.Viewer</code> object that can be used to interact with the Neuroglancer state in Python for advanced functionality.</p> <p>Important</p> <p>The default <code>neuroglancer.Viewer</code> object used here differs from the one used in the <code>neuroglancer</code> python library by not launching a web server on creation. If you want an interactive Neuroglancer viewer that can be run from Python, set <code>interactive=True</code> in the ViewerState initialiation.</p>"},{"location":"usage/statebuilder/#layers","title":"Layers","text":"<p>All layers have a certain common set of properties:</p> <ul> <li><code>source</code>: One or more cloudpaths pointing Neuroglancer at a data source.</li> <li><code>name</code>: A name for the layer, displayed in the tabs.</li> <li><code>visible</code>: A boolean value indicating if the layer is actively visible in the Neuroglancer interface.</li> <li><code>archived</code>: A boolean value indicating if the layer is archived, which removes it from the tab interface but allows it to be re-enabled from the Layers tab.</li> <li><code>shader</code>: A GL shader that can customize how data is rendered in the layer.</li> </ul> <p>In general, the only required property for a simple state is the <code>source</code>, with other properties having reasonable defaults for simple states. However, if you want to use multiple layers of the same type, you will need to set the <code>name</code> property for each layer to avoid conflicts.</p>"},{"location":"usage/statebuilder/#image-layers","title":"Image Layers","text":"<p>Image layers are the simplest type of layer to specify, and are used to display 3d imagery. The most basic image layer is specified with just a source:</p> <pre><code>img_layer = ImageLayer(\n    source='precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie65/em',\n)\n</code></pre> <p>which produces a layer with name <code>img</code>. <pre><code>&gt;&gt;&gt; img_layer.name\n'img'\n</code></pre></p> <p>You can also add multiple sources to an image layer, which will be displayed as a single layer in Neuroglancer by combining them in a list.</p> <pre><code>img_layer_multi = ImageLayer(\n    source=[\n      'precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie35/em',\n      'precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie65/em',\n    ]\n)\n</code></pre> <p>Neuroglancer also lets you specify linear transformations for sources, such as translations or rotations. You can apply these transformations with the more complex <code>Source</code> class, which can specify not only a cloudpath source, but a CoordSpaceTransform that captures an affine transformation matrix. It requires more information, but also allows more complexity. For example, to add a source with a translation:</p> <pre><code>img_layer_transformed = ImageLayer(\n    source=Source(\n        url='precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie65/em',\n        transform=CoordSpaceTransform(\n            output_dimensions=[4,4,40],\n            matrix=[[1, 0, 0, 1000],\n                    [0, 1, 0, 2000.0],\n                    [0, 0, 1, -2000]],\n        )\n    )\n)\n</code></pre> <p>The first three columns of the CoordSpaceTransform specify a linear transform matrix, while the last column is a translation vector. The 4th row is implicit and always <code>[0, 0, 0, 1]</code>, so it is not specified.</p>"},{"location":"usage/statebuilder/#segmentation-layers","title":"Segmentation Layers","text":"<p>Segmentation layers are also volumetric data, but have objects with segment ids that can be selected, hidden, and visualized in 3d using meshes or skeletons. The basic segmentation layer is just like an Image layer:</p> <pre><code>seg_source = SegmentationLayer(\n    name='my_segmentation',\n    source='precomputed://gs://iarpa_microns/minnie/minnie65/seg_m1300'\n)\n</code></pre> <p>However, now we can also select objects by segment id. Let's use the pipeline pattern to build up a segmentation layer with a source, two selected ids, and custom colors for them.</p> <pre><code>seg_layer = (\n    SegmentationLayer()\n    .add_source('precomputed://gs://iarpa_microns/minnie/minnie65/seg_m1300')\n    .add_segments([864691135356428751, 864691136032617659])\n    .add_segment_colors(\n        {\n            864691135356428751: '#ff0000',\n            864691136032617659: '#00ff00'\n        }\n    )\n)\n</code></pre> <p>Packaging that together with an image layer from above,</p> <pre><code>(\n    ViewerState()\n    .add_layer(img_layer)\n    .add_layer(seg_layer)\n).to_link()\n</code></pre> <p>would produce this Neuroglancer link</p> <p>There are also various parameters to set the appearance of the selected meshes and 2d overlays under the <code>set_view_options</code> method.</p> <p>You can also add selections from the data in a dataframe using <code>add_segments_from_data</code>, which will select all the segments in a column of the dataframe.</p> <pre><code>seg_layer = (\n    SegmentationLayer()\n    .add_source('precomputed://gs://iarpa_microns/minnie/minnie65/seg_m1300')\n    .add_segments_from_data(\n        data = my_dataframe,\n        segment_column = 'pt_root_id,\n        visible_column = 'is_visible',\n        color_column = 'color_value',\n    )\n)\n</code></pre> <p>As in images, any specification of sources can be either a string URL or a list of URLs.</p> <p>Would select all segment ids in <code>my_dataframe['pt_root_id']</code> to the segmentation layer, toggle their visibility by the boolean values in <code>my_dataframe['is_visible']</code>, and set their colors to the values in <code>my_dataframe['color_value']</code>. Colors can be hex values or web-readable color names, such as <code>'red'</code>, <code>'blue'</code>, or <code>'green'</code>.</p>"},{"location":"usage/statebuilder/#skeleton-sources","title":"Skeleton Sources","text":"<p>You can add a custom skeleton source to a segmentation layer simply by adding it via <code>add_source</code> or including it on the initial source list.</p>"},{"location":"usage/statebuilder/#segment-properties","title":"Segment Properties","text":"<p>Just like Image layers can have multiple sources, Segmentation layers can also have multiple segmentation sources. In addition to the actual source of segmentation, you can also add sources to represent other aspects of the objects.</p> <p>Segment properties can be treated as an additional source and can be added directly to the list of sources (<code>add_source</code>) if you have an existing or static cloudpath. However, if you want to generate segment properties dynamically from a dataframe, you can use the <code>add_segment_properties</code> method, which will generate the segment properties file, upload it to a CAVE state server, and attach the resulting URL to the segmentation layer. Note that <code>add_segment_properties</code> requires a CAVEclient object and also has a <code>dry_run</code> option to avoid many duplicative uploads while developing your code.</p> <p>Segment properties can be added inline to the ViewerState and do not require a specified segmentation layer if only one segmentation layer is present. There is also a <code>random_columns</code> parameter which can be used to add a random number column to make it easier to subsample sets of cells without using a smaller table. For example, to download a CAVE table and then add it to a viewerstate with one random column, you could do:</p> <pre><code>from caveclient import CAVEclient\nclient = CAVEclient('minnie65_public')\nct_df = client.materialize.tables.allen_column_mtypes_v2.get_all(split_positions=True)\nvs = (\n    ViewerState(client=client)\n    .add_layers_from_client(segmentation='seg')\n    .add_segment_properties(\n        data=ct_df,\n        id_column='pt_supervoxel_id',\n        label_column='target_id',\n        tag_value_columns=['cell_type'],\n        random_columns=1,\n    )\n)\n</code></pre> <p>See the Segment Properties documentation for more information on how to generate segment properties in Neuroglancer and what different options mean.</p>"},{"location":"usage/statebuilder/#skeleton-shader","title":"Skeleton Shader","text":"<p>The <code>shader</code> field of a segmentation layer currently specifies how skeletons are rendered in Neuroglancer. The <code>statebuilder.shaders</code> module has some examples and tooling to help generate these shaders, but GL shaders like this are effectively a new language. Once you have a shader you want to use, you can set it with the <code>add_shader</code> method of the segmentation layer.</p>"},{"location":"usage/statebuilder/#annotation-layers","title":"Annotation Layers","text":"<p>Annotation layers let a user define various types of annotations like points, lines, bounding boxes, and ellipses. Annotations can also be associated with segmentations, allowing you to filter annotations by the data that's being selected.</p> <p>Annotation layers come in two types, local annotation layers that store their annotations directly in the Neuroglancer state and cloud annotation layers that get their annotations from a cloud-hosted source. While they can look and are created with the same functions similar, these behave differently in Neuroglancer and not all functions are available for both types.</p>"},{"location":"usage/statebuilder/#local-annotations","title":"Local Annotations","text":"<p>The simplest annotation layer is a local annotation layer, which can be created with just a name.</p> <pre><code>from nglui.statebuilder import AnnotationLayer\nannotation_layer = AnnotationLayer(name='my_annotations')\n\nviewer_state.add_layer(annotation_layer)\n</code></pre> <p>The simplest way to add annotations is through the <code>add_points</code>, <code>add_lines</code>, <code>add_boxes</code>, and <code>add_ellipses</code> methods. These methods work similarly, taking a dataframe where each row represents an annotation and the columns are specified by parameters.</p> <p>For example, to add points to the annotation layer, you can do:</p> <pre><code>annotation_layer.add_points(\n    data=my_dataframe,\n    point_column='location', # Column with point locations as x,y,z coordinates\n    segment_column='linked_segment', # Column with linked segment ids\n    description_column='description', # Column with annotation descriptions\n    data_resolution=[1, 1, 1], # Resolution of the point data in nm/voxel. Will default to the layer's default resolution if not specified.\n)\n</code></pre> <p>Put together into a pipeline, you could generate a Neuroglancer link with an annotation layer from a dataframe like so:</p> <pre><code>from nglui.statebuilder import ViewerState, AnnotationLayer\n(\n    ViewerState()\n    .add_layers_from_client(client, segmentation='seg') # Sets the name of the segmentation layer to 'seg'\n    .add_layer(\n        AnnotationLayer(\n            name='my_annotations',\n            linked_segmentations='seg', # Uses the `seg` name to link annotations to the segmentation layer\n        )\n        .add_points(\n            data=my_dataframe,\n            point_column='location',\n            segment_column='linked_segment',\n            description_column='description',\n            data_resolution=[1, 1, 1],\n        )\n    )\n).to_link()\n</code></pre> <p>However, while this gives you the most control over details, there's still a lot of boilerplate code to set up an annotation layer, link it to an existing segmentation layer, and then add points to it. If you just want to create a local annotation layer that will automatically link to the first existing segmentation layer in the ViewerState, you can use the <code>add_annotation_layer</code> method of the ViewerState object. Even better, if you want to create a local annotation layer with points, you can use <code>add_points</code> directly on the ViewerState object, which will create a local annotation layer with the specified points and link it to the first segmentation layer in the ViewerState, and do the same annotation creation. For example, the above code can be simplified to:</p> <pre><code>(\n    ViewerState()\n    .add_layers_from_client(client)\n    .add_points(\n        data=my_dataframe,\n        name='my_annotations',\n        point_column='location',\n        segment_column='linked_segment',\n        description_column='description',\n        data_resolution=[1, 1, 1],\n    )\n).to_link()\n</code></pre> <p>This will add a local annotation layer with points defined by the <code>my_dataframe</code> dataframe, where each row has a point location in the <code>location</code> column, a linked segment id in the <code>linked_segment</code> column, and a description in the <code>description</code> column.</p> <p>Note</p> <p>The <code>point_column</code> field can also refer to a situation where the x,y, and z coordinates of the point are stored in separate columns if they are formatted according to <code>{point_column}_x</code>, <code>{point_column}_y</code>, and <code>{point_column}_z</code>.</p> <p>There are also direct class to produce annotations in <code>statebuilder.ngl_annotations</code>, which can be added directly to an annotation layer via <code>add_annotations</code> for even more control.</p>"},{"location":"usage/statebuilder/#tags","title":"Tags","text":"<p>Local annotations can have tags, which is a way to categorize annotations with shortcuts in Neuroglancer. When you make an annotation layer, you can specify a list of tags that will be used to categorize the annotations. The shortcuts for adding these tags will be Shift+Q, Shift+W, Shift+E, and so on. The tags run Q to T for the first five tags, then A to G for the next five tags. A max of ten tags can be used in a single annotation layer in nglui to avoid overloading the interface.</p> <p>You can specify which tags the annotations already in two ways. A <code>tag_column</code> specifies one or more column names, where each column has a single string per row that will be used as the tag for the annotation. With this approach, you can only use one tag per annotation per tag column. Alternatively, you can use <code>tag_bools</code>, which is a list of columns where each column name is taken to be a tag and the value in the column is a boolean indicating if the tag is applied to the annotation. In both cases, the layer will automatically generate the list of required tags based on the columns in the dataframe, added alphabetically if not already present in the specified tag list.</p>"},{"location":"usage/statebuilder/#cloud-annotations","title":"Cloud Annotations","text":"<p>Cloud annotations are similar to local annotations, but they are stored in a cloud-hosted source. Cloud annotations can be used simply by passing a <code>source</code> url to the <code>AnnotationLayer</code> or <code>add_annotation_layer</code> method. The AnnotationLayer object will detect if the <code>source</code> value is not <code>None</code> and will create a cloud annotation layer instead of a local one.</p> <p>Note that cloud annotations don't mix with local annotations, and if you have an explicit source defined then the local annotations will not be created even if they were specified. In addition, cloud annotations cannot currently have tags.</p>"},{"location":"usage/statebuilder/#raw-layers","title":"Raw Layers","text":"<p>Raw layers are a way to add existing layers from Neuroglancer states to the ViewerState without additional processing or linking. You can add a raw layer by calling the <code>add_raw_layer</code> method on the ViewerState object, passing the dictionary representation of the layer which you can get from the state JSON in Neuroglancer or downloaded. Raw layers have few configuration options, becuase the data is intended to be used as-is. However, there are a few changes you can make when bringing them into your ViewerState.</p> <ol> <li>You can specify a new <code>name</code> for the layer, which will replace the existing name, otherwise the name will be inherited from the data in the layer JSON. Similarly, you can adjust visibility and archived settings.</li> <li>You can also provide a <code>source_remap</code> dictionary to remap any source URLs for the layer. For example, if a cloudpath has changed locations or you want to migrate a state from an authenticated production endpoint to a public endpoint, you can provide a mapping of old paths to new paths as a dictionary.</li> </ol> <p>If you're using raw layers, you might find it useful to be using a base state as well. You can provide a <code>base_state</code> state dictionary to the <code>ViewerState</code> class on creation. You can strip out inconvenient parts with functions <code>strip_layers</code> (which strips just the layer definitions and active layer) and <code>strip_state_properties</code>, which offers more selective control. This might be useful if you want to preserve things that cannot be easily set in the python interface such as complex tool panels. </p>"},{"location":"usage/statebuilder/#caveclient-integration","title":"CAVEclient Integration","text":"<p>NGLui integrates with the CAVEclient to make it easy to work with Neuroglancer states that are hosted on CAVE. You can use an initialized CAVEclient object to configure the resolution, image, and segmentation layers of a ViewerState:</p> <pre><code>from caveclient import CAVEclient\nclient = CAVEclient('minnie65_public')\nviewer_state = (\n    ViewerState()\n    .add_layers_from_client(client)\n)\n</code></pre> <p>This will use the info in the CAVEclient to find any relevent information (including skeleton sources for segmentation layers) and add it to the ViewerState.</p> <pre><code>&gt;&gt;&gt; viewer_state.layers\n[ImageLayer(name='imagery', source='precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie65/em'),\n SegmentationLayer(name='segmentation', source=['graphene://https://minnie.microns-daf.com/segmentation/table/minnie65_public', 'precomputed://middleauth+https://minnie.microns-daf.com/skeletoncache/api/v1/minnie65_public/precomputed/skeleton/'])]\n</code></pre> <p>There are a variety of parameters to control layer properties here, as well. In all cases, the image layer will be added first (if used) and then the segmentation layer.</p>"},{"location":"usage/statebuilder/#mapping-data","title":"Mapping Data","text":"<p>In some situations, it can make sense to separate data from the Neuroglancer state creation rules. This effectively allows you to build one set of rules and then apply them to different data with the same code.</p> <p>This is handled now through a special <code>DataMap</code> class that can be used to replace certain arguments in functions relating to data sources and annotation creation. For example, instead of making a Image and Segmentation layers with pre-specified sources, you can add the source as a 'DataMap<code>object. Each DataMap has a</code>key` attribute that is used to map the data you will provide later to the correct role in state creation.</p> <pre><code>from nglui.statebuilder import ViewerState, SegmentationLayer, DataMap\n\nviewer_state = (\n    ViewerState()\n    .add_image_layer(source=DataMap('img_source'))\n    .add_segmentation_layer(source=DataMap('seg_source'))\n)\n</code></pre> <p>If you tried to run <code>viewer_state.to_link()</code> now, you would get an <code>UnmappedDataError</code> indicating that these values have yet to be replaced with actual data.</p> <p>To actually map data, you can use the <code>map</code> method of the ViewerState object, which takes a dictionary of key-value pairs where the keys are the DataMap keys and the values are the actual data to be used. For example, to replicate the previous example with the CAVEclient info, you could do:</p> <pre><code>viewer_state.map(\n    {\n        'img_source': 'precomputed://https://bossdb-open-data.s3.amazonaws.com/iarpa_microns/minnie/minnie65/em',\n        'seg_source': [\n                'graphene://https://minnie.microns-daf.com/segmentation/table/minnie65_public',\n            ],\n    }\n).to_link()\n</code></pre> <p>This will replace the DataMap keys with the actual data and produce a Neuroglancer link with the specified sources. Applying this across a list of data sources can easily generate a large collection of neuroglancer states.</p> <p>The other principle use of DataMaps is to support annotation creation by replacing the <code>data</code> argument in the <code>add_points</code>, <code>add_lines</code>, <code>add_boxes</code>, and <code>add_ellipses</code> methods. For example, you can create a DataMap for the annotation data and then use it to add points to the annotation layer with the following pattern:</p> <pre><code>from nglui.statebuilder import ViewerState, AnnotationLayer, DataMap\nviewer_state = (\n    ViewerState()\n    .add_annotation_layer(name='my_annotations', linked_segmentations='seg')\n    .add_points(\n        data=DataMap('annotation_data'),\n        point_column='location',\n        segment_column='linked_segment',\n        description_column='description',\n        data_resolution=[1, 1, 1],\n    )\n)\n\nviewer_state.map(\n    {\n        'annotation_data': my_dataframe,\n    }\n).to_link()\n</code></pre> <p>Note that the <code>map</code> method returns the ViewerState object itself, so you could in principle chain maps together to sequentially replace DataMap values. Only when all DataMaps are resolv$$ed will the <code>to_link</code> or other export functions work without error.</p> <p>A DataMap with an empty argument is treated as an implicit \"None\" value and a <code>map</code> call that gets anything other than a dictionary will be treated as a dictionary with a single key of <code>None</code> and the value being the data to be mapped.</p>"}]}